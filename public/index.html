<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <link rel="icon" href="/public/resources/images/icons/threat.png" type="image/png">
    <title>Excelsior Deckbuilder - Characters Database</title>
    <link rel="stylesheet" href="/css/index.css">
    <link rel="stylesheet" href="/css/deck-selection.css">
    <link rel="stylesheet" href="/css/draw-hand.css">
    <link rel="stylesheet" href="/css/collection-view.css">
    <link rel="stylesheet" href="/css/database-view.css">
    <link rel="stylesheet" href="/css/card-tables.css">
    <!-- Authentication Service -->
    <script src="/js/auth-service.js"></script>
    <script src="/js/components/simulate-ko.js"></script>
    <script src="/js/components/draw-hand.js"></script>

    <!-- Global alphabetization scheme (must load before any sorting code runs) -->
    <script src="/js/alphabetization.js"></script>
    
    <!-- Global Navigation Component -->
    <link rel="stylesheet" href="/components/globalNav.css">
    <script src="/components/globalNav.js"></script>
    
    <!-- Login Component -->
    <link rel="stylesheet" href="/components/login/login.css">
    
    <!-- Extracted JavaScript Files -->
    <script src="/js/utilities.js"></script>
    <script src="/js/layout-manager.js"></script>
    <script src="/js/deck-management.js"></script>
    <script src="/js/card-display.js"></script>
    <script src="/js/all-cards-display.js"></script>
    <script src="/js/deck-editor-simple.js"></script>
    <script src="/js/search-filter.js"></script>
    <script src="/js/modal-ui.js"></script>
    <script src="/js/auth-app-init.js"></script>
    <script src="/components/login/login.js"></script>
    <script src="/js/app-initialization.js"></script>
    <script src="/js/data-loading.js"></script>
    <script src="/js/deck-background.js"></script>
    <script src="/js/deck-editor-core.js"></script>
    <script src="/js/components/deck-export.js"></script>
    <script src="/js/components/deck-import.js"></script>
    <link rel="stylesheet" href="/css/deck-editor-search.css">
    <link rel="stylesheet" href="/css/deck-background.css">
    <script src="/js/services/CardSearchService.js"></script>
    <script src="/js/components/DeckEditorSearch.js"></script>
    <script src="/js/card-display-functions.js"></script>
    <script src="/js/collection-view.js"></script>
        <script src="/js/search-filter-functions.js"></script>
        <script src="/js/deck-management-functions.js"></script>
    <script src="/js/ui-utility-functions.js"></script>
    <script src="/js/layout-drag-drop-functions.js"></script>
    <script src="/js/validation-calculation-functions.js"></script>
    <script src="/js/remaining-utility-functions.js"></script>
    <script src="/js/template-loader.js"></script>
    <script src="/js/event-binder.js"></script>
    <script src="/js/filter-functions.js"></script>
    <script src="/js/card-filter-toggles.js"></script>
    <script src="/js/card-data-display.js"></script>
    <script src="/js/deck-editor-rendering.js"></script>
    <script src="/js/deck-card-operations.js"></script>
    <script src="/js/deck-validation.js"></script>
    <script src="/js/card-image-utils.js"></script>
    <script src="/js/deck-editor-layout.js"></script>
    <script src="/js/screenshot-view.js"></script>
    <script src="/js/ui-preferences.js"></script>
    <script src="/js/deck-editor-search-inline.js"></script>
    <script src="/js/game-logic.js"></script>
    <script src="/js/alternate-art-modal.js"></script>
    <script src="/js/card-hover-modal.js"></script>
    <!-- Deck selection (deck list tiles) -->
    <script src="/js/deck-selection/deckTileImages.js"></script>
    <script src="/js/deck-selection/deckTileTimestamps.js"></script>
    <script src="/js/deck-selection/deckTilesRenderer.js"></script>
    <script src="/js/deck-selection/deckTileMenu.js"></script>
    <script src="/js/deck-selection/index.js"></script>
</head>
<body>
    <!-- Login Modal will be loaded by login.js component -->
    
    <div class="container" id="mainContainer" style="display: block; opacity: 1;">
        <!-- Global Navigation Component -->
        <div id="globalNav"></div>


        <div id="database-view" class="database-section" style="display: none;">
            <!-- Hidden stats elements for functionality (not displayed) -->
            <div class="stats" style="display: none;">
                <div class="stat-card">
                    <div class="stat-number" id="total-characters">-</div>
                    <div class="stat-label">Characters</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number" id="total-special-cards">-</div>
                    <div class="stat-label">Special Cards</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number" id="total-missions">-</div>
                    <div class="stat-label">Missions</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number" id="total-events">-</div>
                    <div class="stat-label">Events</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number" id="total-locations">-</div>
                    <div class="stat-label">Locations</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number" id="db-total-decks">-</div>
                    <div class="stat-label">Decks</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number" id="total-users">-</div>
                    <div class="stat-label">Users</div>
                </div>
            </div>
            <div class="section-header">
            </div>
            
            <div class="tab-container">
                <div class="tab-row">
                    <button class="tab-button active" data-click-handler="switchTab" data-tab="all-cards">All</button>
                    <button class="tab-button" data-click-handler="switchTab" data-tab="characters">Characters</button>
                    <button class="tab-button" data-click-handler="switchTab" data-tab="special-cards">Special Cards</button>
                    <button class="tab-button" data-click-handler="switchTab" data-tab="advanced-universe">Universe: Advanced</button>
                    <button class="tab-button" data-click-handler="switchTab" data-tab="locations">Locations</button>
                    <button class="tab-button" data-click-handler="switchTab" data-tab="aspects">Aspects</button>
                    <button class="tab-button" data-click-handler="switchTab" data-tab="missions">Missions</button>
                </div>
                <div class="tab-row">
                    <button class="tab-button" data-click-handler="switchTab" data-tab="events">Events</button>
                    <button class="tab-button" data-click-handler="switchTab" data-tab="teamwork">Universe: Teamwork</button>
                    <button class="tab-button" data-click-handler="switchTab" data-tab="ally-universe">Universe: Ally</button>
                    <button class="tab-button" data-click-handler="switchTab" data-tab="training">Universe: Training</button>
                    <button class="tab-button" data-click-handler="switchTab" data-tab="basic-universe">Universe: Basic</button>
                    <button class="tab-button" data-click-handler="switchTab" data-tab="power-cards">Power Cards</button>
                </div>
            </div>

            <div class="search-container" id="search-container" style="display: none;">
                <input type="text" class="search-input" id="search-input" placeholder="Search...">
            </div>


            <div class="table-container" id="all-cards-tab" style="display: block;">
                <div id="all-cards-filter-container" style="margin-bottom: 15px; padding: 10px; background: rgba(0, 0, 0, 0.5); border-radius: 5px; border: 1px solid rgba(255, 255, 255, 0.1);">
                    <div id="all-cards-type-filters" style="display: flex; flex-wrap: wrap; gap: 8px; justify-content: center;">
                        <button class="card-type-filter-btn active" data-card-type="character">Characters</button>
                        <button class="card-type-filter-btn active" data-card-type="special">Special Cards</button>
                        <button class="card-type-filter-btn active" data-card-type="advanced-universe">Advanced Universe</button>
                        <button class="card-type-filter-btn active" data-card-type="location">Locations</button>
                        <button class="card-type-filter-btn active" data-card-type="aspect">Aspects</button>
                        <button class="card-type-filter-btn active" data-card-type="mission">Missions</button>
                        <button class="card-type-filter-btn active" data-card-type="event">Events</button>
                        <button class="card-type-filter-btn active" data-card-type="teamwork">Teamwork</button>
                        <button class="card-type-filter-btn active" data-card-type="ally-universe">Ally Universe</button>
                        <button class="card-type-filter-btn active" data-card-type="training">Training</button>
                        <button class="card-type-filter-btn active" data-card-type="basic-universe">Basic Universe</button>
                        <button class="card-type-filter-btn active" data-card-type="power">Power Cards</button>
                    </div>
                </div>
                <div id="all-cards-grid-container" style="display: grid; grid-template-columns: repeat(5, 1fr); gap: 15px; padding: 15px;">
                    <!-- Cards will be rendered here -->
                </div>
            </div>

            <div class="table-container" id="characters-tab" style="display: none;">
                <table id="characters-table">
                    <thead>
                        <tr>
                            <th>Image</th>
                            <th></th>
                            <th>Name</th>
                            <th>Energy</th>
                            <th>Combat</th>
                            <th>Brute Force</th>
                            <th>Intelligence</th>
                            <th>Threat Level</th>
                            <th>Inherent Abilities</th>
                        </tr>
                        <tr class="filter-row">
                            <th>
                                <button id="clear-filters" class="clear-filters-btn">Clear All Filters</button>
                            </th>
                            <th></th>
                            <th>
                                <input type="text" class="header-filter" placeholder="Search names...">
                            </th>
                            <th>
                                <div class="column-filters">
                                    <input type="number" class="filter-input equals" data-column="energy" placeholder="=" min="0" max="8">
                                    <input type="number" class="filter-input min" data-column="energy" placeholder="Min" min="0" max="8">
                                    <input type="number" class="filter-input max" data-column="energy" placeholder="Max" min="0" max="8">
                                </div>
                            </th>
                            <th>
                                <div class="column-filters">
                                    <input type="number" class="filter-input equals" data-column="combat" placeholder="=" min="0" max="8">
                                    <input type="number" class="filter-input min" data-column="combat" placeholder="Min" min="0" max="8">
                                    <input type="number" class="filter-input max" data-column="combat" placeholder="Max" min="0" max="8">
                                </div>
                            </th>
                            <th>
                                <div class="column-filters">
                                    <input type="number" class="filter-input equals" data-column="brute_force" placeholder="=" min="0" max="8">
                                    <input type="number" class="filter-input min" data-column="brute_force" placeholder="Min" min="0" max="8">
                                    <input type="number" class="filter-input max" data-column="brute_force" placeholder="Max" min="0" max="8">
                                </div>
                            </th>
                            <th>
                                <div class="column-filters">
                                    <input type="number" class="filter-input equals" data-column="intelligence" placeholder="=" min="0" max="8">
                                    <input type="number" class="filter-input min" data-column="intelligence" placeholder="Min" min="0" max="8">
                                    <input type="number" class="filter-input max" data-column="intelligence" placeholder="Max" min="0" max="8">
                                </div>
                            </th>
                            <th>
                                <div class="column-filters">
                                    <input type="number" class="filter-input equals" data-column="threat_level" placeholder="=" min="0">
                                    <input type="number" class="filter-input min" data-column="threat_level" placeholder="Min" min="0">
                                    <input type="number" class="filter-input max" data-column="threat_level" placeholder="Max" min="0">
                                </div>
                            </th>
                            <th>
                                <div class="inherent-abilities-filters">
                                    <label class="toggle-label">
                                        <input type="checkbox" id="has-inherent-ability" class="ability-toggle">
                                        <span class="toggle-text">Has Inherent Ability</span>
                                    </label>
                                    <label class="toggle-label">
                                        <input type="checkbox" id="has-no-inherent-ability" class="ability-toggle">
                                        <span class="toggle-text">Has No Inherent Ability</span>
                                    </label>
                                    <input type="text" class="header-filter" placeholder="Search abilities...">
                                </div>
                            </th>
                        </tr>
                    </thead>
                    <tbody id="characters-tbody">
                        <tr>
                            <td colspan="8" class="loading">Loading characters...</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <div class="table-container" id="special-cards-tab" style="display: none;">
                <table id="special-cards-table">
                    <thead>
                        <tr>
                            <th>Image</th>
                            <th></th>
                            <th>Name</th>
                            <th>Character</th>
                            <th>Card Effect</th>
                        </tr>
                        <tr class="filter-row">
                            <th>
                                <button class="clear-filters-btn" onclick="clearSpecialCardFilters()">Clear All Filters</button>
                            </th>
                            <th></th>
                            <th>
                                <input type="text" class="header-filter" placeholder="Search names..." data-column="name">
                            </th>
                            <th>
                                <input type="text" class="header-filter" placeholder="Search characters..." data-column="character">
                            </th>
                            <th>
                                <input type="text" class="header-filter" placeholder="Search effects..." data-column="card_effect">
                            </th>
                        </tr>
                    </thead>
                    <tbody id="special-cards-tbody">
                        <tr>
                            <td colspan="5" class="loading">Loading special cards...</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <div class="table-container" id="advanced-universe-tab" style="display: none;">
                <table id="advanced-universe-table">
                    <thead>
                        <tr>
                            <th>Image</th>
                            <th></th>
                            <th>Name</th>
                            <th>Character</th>
                            <th>Card Effect</th>
                            <th class="one-per-deck-advanced-column">One Per Deck</th>
                        </tr>
                        <tr class="filter-row">
                            <th>
                                <button class="clear-filters-btn" onclick="clearAdvancedUniverseFilters()">Clear All Filters</button>
                            </th>
                            <th></th>
                            <th></th>
                            <th>
                                <input type="text" class="header-filter" placeholder="Search characters..." data-column="character">
                            </th>
                            <th>
                                <input type="text" class="header-filter" placeholder="Search effects..." data-column="card_effect">
                            </th>
                            <th class="one-per-deck-advanced-column"></th>
                        </tr>
                    </thead>
                    <tbody id="advanced-universe-tbody">
                        <tr>
                            <td colspan="5" class="loading">Loading advanced universe cards...</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <div class="table-container" id="locations-tab" style="display: none;">
                <table id="locations-table">
                    <thead>
                        <tr>
                            <th>Image</th>
                            <th></th>
                            <th>Name</th>
                            <th>Threat Level</th>
                            <th>Special Ability</th>
                        </tr>
                        <tr class="filter-row">
                            <th>
                                <button class="clear-filters-btn" onclick="clearLocationFilters()">Clear All Filters</button>
                            </th>
                            <th></th>
                            <th></th>
                            <th>
                                <div class="column-filters">
                                    <div class="range-inputs">
                                        <input type="number" id="location-threat-min" placeholder="Min" min="0" max="3" class="filter-input">
                                        <span>-</span>
                                        <input type="number" id="location-threat-max" placeholder="Max" min="0" max="3" class="filter-input">
                                    </div>
                                </div>
                            </th>
                            <th>
                                <input type="text" class="header-filter" placeholder="Search abilities..." data-column="special_ability">
                            </th>
                        </tr>
                    </thead>
                    <tbody id="locations-tbody">
                        <tr>
                            <td colspan="4" class="loading">Loading locations...</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <div class="table-container" id="aspects-tab" style="display: none;">
                <table id="aspects-table">
                    <thead>
                        <tr>
                            <th>Image</th>
                            <th></th>
                            <th>Card Name</th>
                            <th>Location</th>
                            <th>Card Effect</th>
                            <th class="fortifications-column">Fortifications</th>
                            <th class="one-per-deck-column">One Per Deck</th>
                        </tr>
                        <tr class="filter-row">
                            <th>
                                <button class="clear-filters-btn" onclick="clearAspectsFilters()">Clear All Filters</button>
                            </th>
                            <th></th>
                            <th>
                                <input type="text" class="header-filter" placeholder="Search names..." data-column="card_name">
                            </th>
                            <th>
                                <input type="text" class="header-filter" placeholder="Search locations..." data-column="location">
                            </th>
                            <th>
                                <input type="text" class="header-filter" placeholder="Search effects..." data-column="card_effect">
                            </th>
                            <th class="fortifications-column"></th>
                            <th class="one-per-deck-column"></th>
                        </tr>
                    </thead>
                    <tbody id="aspects-tbody">
                        <tr>
                            <td colspan="6" class="loading">Loading aspects...</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <div class="table-container" id="missions-tab" style="display: none;">
                <table id="missions-table">
                    <thead>
                        <tr>
                            <th>Image</th>
                            <th></th>
                            <th>Mission Set</th>
                            <th>Card Name</th>
                        </tr>
                        <tr class="filter-row">
                            <th>
                                <button class="clear-filters-btn" onclick="clearMissionsFilters()">Clear All Filters</button>
                            </th>
                            <th></th>
                            <th>
                                <div class="column-filters">
                                    <div class="checkbox-group">
                                        <label><input type="checkbox" value="King of the Jungle" checked> King of the Jungle</label>
                                        <label><input type="checkbox" value="The Call of Cthulhu" checked> The Call of Cthulhu</label>
                                        <label><input type="checkbox" value="Time Wars: Rise of the Gods" checked> Time Wars: Rise of the Gods</label>
                                        <label><input type="checkbox" value="The Warlord of Mars" checked> Warlord of Mars</label>
                                    </div>
                                </div>
                            </th>
                            <th></th>
                        </tr>
                    </thead>
                    <tbody id="missions-tbody">
                        <tr>
                            <td colspan="3" class="loading">Loading missions...</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <div class="table-container" id="events-tab" style="display: none;">
                <table id="events-table">
                    <thead>
                        <tr>
                            <th>Image</th>
                            <th></th>
                            <th>Name</th>
                            <th>Mission Set</th>
                            <th>Game Effect</th>
                            <th>Flavor Text</th>
                        </tr>
                        <tr class="filter-row">
                            <th>
                                <button class="clear-filters-btn" onclick="clearEventsFilters()">Clear All Filters</button>
                            </th>
                            <th></th>
                            <th></th>
                            <th>
                                <div class="column-filters">
                                    <div class="checkbox-group">
                                        <label><input type="checkbox" value="King of the Jungle" checked> King of the Jungle</label>
                                        <label><input type="checkbox" value="The Call of Cthulhu" checked> The Call of Cthulhu</label>
                                        <label><input type="checkbox" value="Time Wars: Rise of the Gods" checked> Time Wars: Rise of the Gods</label>
                                        <label><input type="checkbox" value="The Warlord of Mars" checked> Warlord of Mars</label>
                                    </div>
                                </div>
                            </th>
                            <th>
                                <input type="text" class="header-filter" placeholder="Search effects..." data-column="game_effect">
                            </th>
                            <th></th>
                        </tr>
                    </thead>
                    <tbody id="events-tbody">
                        <tr>
                            <td colspan="5" class="loading">Loading events...</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <div class="table-container" id="teamwork-tab" style="display: none;">
                <table id="teamwork-table">
                    <thead>
                        <tr>
                            <th>Image</th>
                            <th></th>
                            <th>To Use</th>
                            <th>Acts As</th>
                            <th>Followup Attack Types</th>
                            <th>1st Attack Bonus</th>
                            <th>2nd Attack Bonus</th>
                        </tr>
                        <tr class="filter-row">
                            <th>
                                <button class="clear-filters-btn" onclick="clearTeamworkFilters()">Clear All Filters</button>
                            </th>
                            <th></th>
                            <th></th>
                            <th></th>
                            <th></th>
                            <th></th>
                            <th></th>
                        </tr>
                    </thead>
                    <tbody id="teamwork-tbody">
                        <tr>
                            <td colspan="6" class="loading">Loading teamwork cards...</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <div class="table-container" id="ally-universe-tab" style="display: none;">
                <table id="ally-universe-table">
                    <thead>
                        <tr>
                            <th>Image</th>
                            <th></th>
                            <th>Card Name</th>
                            <th>Stat to Use</th>
                            <th>Stat Type</th>
                            <th>Attack Value</th>
                            <th>Attack Type</th>
                            <th>Card Text</th>
                        </tr>
                        <tr class="filter-row">
                            <th>
                                <button class="clear-filters-btn" onclick="clearAllyUniverseFilters()">Clear All Filters</button>
                            </th>
                            <th></th>
                            <th></th>
                            <th></th>
                            <th></th>
                            <th></th>
                            <th></th>
                            <th></th>
                        </tr>
                    </thead>
                    <tbody id="ally-universe-tbody">
                        <tr>
                            <td colspan="7" class="loading">Loading allies...</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <div class="table-container" id="training-tab" style="display: none;">
                <table id="training-table">
                    <thead>
                        <tr>
                            <th>Image</th>
                            <th></th>
                            <th>Card Name</th>
                            <th>Type 1</th>
                            <th>Type 2</th>
                            <th>Value to Use</th>
                            <th>Bonus</th>
                        </tr>
                        <tr class="filter-row">
                            <th>
                                <button class="clear-filters-btn" onclick="clearTrainingFilters()">Clear All Filters</button>
                            </th>
                            <th></th>
                            <th></th>
                            <th></th>
                            <th></th>
                            <th></th>
                            <th></th>
                        </tr>
                    </thead>
                    <tbody id="training-tbody">
                        <tr>
                            <td colspan="6" class="loading">Loading training...</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <div class="table-container" id="basic-universe-tab" style="display: none;">
                <table id="basic-universe-table">
                    <thead>
                        <tr>
                            <th>Image</th>
                            <th></th>
                            <th>Card Name</th>
                            <th>Type</th>
                            <th>Value to Use</th>
                            <th>Bonus</th>
                        </tr>
                        <tr class="filter-row">
                            <th>
                                <button class="clear-filters-btn" onclick="clearBasicUniverseFilters()">Clear All Filters</button>
                            </th>
                            <th></th>
                            <th></th>
                            <th>
                                <div class="column-filters">
                                    <div class="checkbox-group">
                                        <label><input type="checkbox" value="Energy" checked> Energy</label>
                                        <label><input type="checkbox" value="Combat" checked> Combat</label>
                                        <label><input type="checkbox" value="Brute Force" checked> Brute Force</label>
                                        <label><input type="checkbox" value="Intelligence" checked> Intelligence</label>
                                    </div>
                                </div>
                            </th>
                            <th>
                                <div class="column-filters">
                                    <input type="number" class="filter-input equals" data-column="value" placeholder="=" min="6" max="7">
                                    <div class="range-inputs">
                                        <input type="number" id="basic-value-min" placeholder="Min" min="6" max="7" class="filter-input">
                                        <span>-</span>
                                        <input type="number" id="basic-value-max" placeholder="Max" min="6" max="7" class="filter-input">
                                    </div>
                                </div>
                            </th>
                            <th>
                                <div class="column-filters">
                                    <input type="number" class="filter-input equals" data-column="bonus" placeholder="=" min="2" max="3">
                                    <div class="range-inputs">
                                        <input type="number" id="basic-bonus-min" placeholder="Min" min="2" max="3" class="filter-input">
                                        <span>-</span>
                                        <input type="number" id="basic-bonus-max" placeholder="Max" min="2" max="3" class="filter-input">
                                    </div>
                                </div>
                            </th>
                        </tr>
                    </thead>
                    <tbody id="basic-universe-tbody">
                        <tr>
                            <td colspan="5" class="loading">Loading basic universe...</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="table-container" id="power-cards-tab" style="display: none;">
                <table id="power-cards-table">
                    <thead>
                        <tr>
                            <th>Image</th>
                            <th></th>
                            <th>Power Type</th>
                            <th>Value</th>
                            <th>Set</th>
                        </tr>
                        <tr class="filter-row">
                            <th>
                                <button class="clear-filters-btn" onclick="clearPowerCardFilters()">Clear All Filters</button>
                            </th>
                            <th></th>
                            <th>
                                <div class="column-filters">
                                    <div class="checkbox-group power-cards-checkbox-group">
                                        <div class="checkbox-column">
                                            <label><input type="checkbox" value="Energy" checked data-filter-type="power-type"> Energy</label>
                                            <label><input type="checkbox" value="Combat" checked data-filter-type="power-type"> Combat</label>
                                            <label><input type="checkbox" value="Brute Force" checked data-filter-type="power-type"> Brute Force</label>
                                        </div>
                                        <div class="checkbox-column">
                                            <label><input type="checkbox" value="Intelligence" checked data-filter-type="power-type"> Intelligence</label>
                                            <label><input type="checkbox" value="Any-Power" checked data-filter-type="power-type"> Any-Power</label>
                                            <label><input type="checkbox" value="Multi Power" checked data-filter-type="power-type"> Multi-Power</label>
                                        </div>
                                    </div>
                                </div>
                            </th>
                            <th>
                                <div class="column-filters">
                                    <div class="range-inputs">
                                        <input type="number" id="power-value-min" placeholder="Min" min="1" max="8" class="filter-input">
                                        <span>-</span>
                                        <input type="number" id="power-value-max" placeholder="Max" min="1" max="8" class="filter-input">
                                    </div>
                                </div>
                            </th>
                            <th>
                                <div class="column-filters">
                                    <div class="checkbox-group">
                                        <label><input type="checkbox" value="ERB" checked data-filter-type="set"> ERB</label>
                                        <label><input type="checkbox" value="SKY" checked data-filter-type="set"> SKY</label>
                                        <label><input type="checkbox" value="TFCP" checked data-filter-type="set"> TFCP</label>
                                    </div>
                                </div>
                            </th>
                        </tr>
                    </thead>
                    <tbody id="power-cards-tbody">
                        <tr>
                            <td colspan="5" class="loading">Loading power cards...</td>
                        </tr>
                    </tbody>
                </table>
            </div>

        </div>

        <!-- Collection View -->
        <div id="collection-view" class="collection-section" style="display: none;">
            <!-- Search Bar -->
            <div class="collection-search-container">
                <input type="text" 
                       id="collectionSearchInput" 
                       class="collection-search-input" 
                       placeholder="Search all cards to add to collection...">
                <div id="collectionSearchResults" class="collection-search-results" style="display: none;"></div>
            </div>

            <!-- Collection Cards List -->
            <div class="collection-cards-container">
                <div id="collectionCardsList" class="collection-cards-list">
                    <div class="collection-loading">Loading collection...</div>
                </div>
            </div>
        </div>

        <!-- Deck Builder Section -->
        <div id="deck-builder" class="deck-builder-section" style="display: none; opacity: 0; transition: opacity 120ms ease-in-out;">
            <!-- Deck List -->
            <div class="deck-list-container">
                <div class="deck-list" id="deck-list">
                    <!-- Decks will be loaded here -->
                </div>
            </div>
        </div>
    </div>

    <!-- Image Modal -->
    <div id="imageModal" class="modal" data-close-handler="closeModal">
        <div class="modal-content" data-stop-propagation="true">
            <img id="modalImage" src="" alt="Card Image">
            <div id="modalCaption"></div>
        </div>
    </div>

    <!-- Create Deck Modal -->
    <div id="createDeckModal" class="modal" data-close-handler="closeCreateDeckModal">
        <div class="modal-content create-deck-modal" data-stop-propagation="true">
            <div class="modal-header">
            <h3>Create New Deck</h3>
            </div>
            <form id="createDeckForm">
                <div class="form-row">
                <div class="form-group">
                    <label for="deckName">Deck Name:</label>
                    <input type="text" id="deckName" name="deckName" required placeholder="Enter deck name">
                </div>
                </div>
                <div class="form-row">
                    <div class="form-group">
                        <label for="characterSelect">Characters: <span style="font-style: italic; color: #666; font-weight: normal; font-size: 0.9em;">Optional</span></label>
                        <div class="character-selection">
                            <select id="characterSelect" class="character-dropdown">
                                <option value="">Select a character to add...</option>
                            </select>
                            <div id="selectedCharacters" class="selected-characters">
                                <!-- Selected characters will appear here -->
                            </div>
                        </div>
                    </div>
                </div>
                <div class="form-actions">
                    <button type="button" data-click-handler="closeCreateDeckModal" class="btn-secondary">Cancel</button>
                    <button type="submit" class="btn-primary">Save</button>
                </div>
            </form>
        </div>
    </div>

    <!-- View/Edit Deck Modal -->
    <div id="viewDeckModal" class="modal" data-close-handler="closeViewDeckModal">
        <div class="modal-content large-modal" data-stop-propagation="true">
            <div class="modal-header">
                <h3 id="viewDeckTitle">Deck Details</h3>
                <button class="close-btn" data-click-handler="closeViewDeckModal">Ã—</button>
            </div>
            <div class="modal-body">
                <div class="deck-info-section">
                    <div class="deck-metadata">
                        <div class="metadata-item">
                            <label>Created:</label>
                            <span id="viewDeckCreated">-</span>
                        </div>
                        <div class="metadata-item">
                            <label>Last Modified:</label>
                            <span id="viewDeckModified">-</span>
                        </div>
                        <div class="metadata-item">
                            <label>Total Cards:</label>
                            <span id="viewDeckCardCount">-</span>
                        </div>
                    </div>
                </div>
                
                <div class="deck-cards-section">
                    <div class="section-header">
                        <h4>Cards in Deck</h4>
                        <button class="add-cards-btn" data-click-handler="showAddCardsModal">Add Cards</button>
                    </div>
                    <div class="deck-cards-list" id="deckCardsList">
                        <!-- Cards will be loaded here -->
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Add Cards Modal -->
    <div id="addCardsModal" class="modal" data-close-handler="closeAddCardsModal">
        <div class="modal-content large-modal" data-stop-propagation="true">
            <div class="modal-header">
                <h3>Add Cards to Deck</h3>
                <button class="close-btn" data-click-handler="closeAddCardsModal">Ã—</button>
            </div>
            <div class="modal-body">
                <div class="card-search-section">
                    <div class="search-controls">
                        <select id="cardTypeFilter" class="card-type-select">
                            <option value="">All Card Types</option>
                            <option value="character">Characters</option>
                            <option value="special">Special Cards</option>
                            <option value="location">Locations</option>
                            <option value="mission">Missions</option>
                            <option value="event">Events</option>
                            <option value="aspect">Aspects</option>
                            <option value="advanced-universe">Universe: Advanced</option>
                            <option value="teamwork">Universe: Teamwork</option>
                            <option value="ally-universe">Universe: Ally</option>
                            <option value="training">Universe: Training</option>
                            <option value="basic-universe">Universe: Basic</option>
                            <option value="power">Power Cards</option>
                        </select>
                        <input type="text" id="cardSearchInput" class="card-search-input" placeholder="Search cards...">
                    </div>
                    <div class="card-results" id="cardResults">
                        <!-- Search results will appear here -->
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Card Hover Modal -->
    <div id="cardHoverModal" class="card-hover-modal">
        <div class="card-hover-content">
            <img id="cardHoverImage" src="" alt="Card" class="card-hover-image">
            <div id="cardHoverCaption" class="card-hover-caption"></div>
        </div>
    </div>
    <!-- Deck Editor Modal -->
    <div id="deckEditorModal" class="modal" data-close-handler="closeDeckEditor">
        <div class="modal-content deck-editor-modal" data-stop-propagation="true">
            <div class="modal-header">
                <!-- Single row with title/description on left, centered stats, and action buttons on right -->
                <div class="deck-editor-top-row">
                    <!-- Left side: Deck Title and Description -->
                    <div class="deck-editor-title-section">
                        <div class="deck-title-with-validation">
                            <h3 id="deckEditorTitle" class="editable-title" data-edit-handler="startEditingTitle">Edit Deck</h3>
                            <div class="deck-title-badges" aria-label="Deck badges">
                                <span id="deckTitleValidationBadge" class="deck-validation-badge"></span>
                                <span id="readOnlyBadge" class="deck-validation-badge read-only" style="display: none;">Read-Only</span>
                            </div>
                        </div>
                        <p id="deckEditorDescription" class="deck-description editable-description" data-edit-handler="startEditingDescription"></p>
                        <div id="readOnlyIndicator" class="read-only-indicator" style="display: none;">
                            <span class="read-only-text">ðŸ“– Read Only Mode</span>
                        </div>
                    </div>
                    
                    <!-- Center: Deck Summary Section -->
                    <div class="deck-summary-section">
                        <div class="deck-summary-content">
                            <div class="deck-summary-stats">
                                <div class="summary-stat">
                                    <span class="stat-label">Total Cards:</span>
                                    <span class="stat-value" id="deckTotalCards">0</span>
                                </div>
                                <div class="deck-stats-divider"></div>
                                <div class="summary-stat">
                                    <span class="stat-label">Total Threat:</span>
                                    <span class="stat-value" id="deckTotalThreat">0</span>
                                </div>
                                <div class="summary-stat">
                                    <span class="stat-label">Max Energy:</span>
                                    <span class="stat-value" id="deckMaxEnergy">0</span>
                                </div>
                                <div class="summary-stat">
                                    <span class="stat-label">Max Combat:</span>
                                    <span class="stat-value" id="deckMaxCombat">0</span>
                                </div>
                                <div class="summary-stat">
                                    <span class="stat-label">Max Brute Force:</span>
                                    <span class="stat-value" id="deckMaxBruteForce">0</span>
                                </div>
                                <div class="summary-stat">
                                    <span class="stat-label">Max Intelligence:</span>
                                    <span class="stat-value" id="deckMaxIntelligence">0</span>
                                </div>
                                <div class="deck-stats-divider"></div>
                                <div class="summary-stat">
                                    <span class="stat-label">Total Energy:</span>
                                    <span class="stat-value" id="deckTotalEnergy">0</span>
                                </div>
                                <div class="summary-stat">
                                    <span class="stat-label">Total Combat:</span>
                                    <span class="stat-value" id="deckTotalCombat">0</span>
                                </div>
                                <div class="summary-stat">
                                    <span class="stat-label">Total Brute Force:</span>
                                    <span class="stat-value" id="deckTotalBruteForce">0</span>
                                </div>
                                <div class="summary-stat">
                                    <span class="stat-label">Total Intelligence:</span>
                                    <span class="stat-value" id="deckTotalIntelligence">0</span>
                                </div>
                            </div>
                            <div class="deck-summary-validation" id="deckSummaryValidation">
                                <!-- Validation content will be displayed here -->
                            </div>
                        </div>
                    </div>
                    
                    <!-- Right side: Utility buttons + Action Buttons -->
                    <div class="deck-editor-right-controls" aria-label="Deck editor controls">
                        <div class="deck-editor-utility-actions" aria-label="Deck editor utility buttons">
                            <button class="remove-all-btn" id="drawHandBtn" data-click-handler="toggleDrawHand" disabled title="Deck must contain at least 8 playable cards.">Draw Hand</button>
                            <!-- Keep Background button in DOM to prevent header reflow; shown/enabled by DeckBackgroundManager when available -->
                            <button class="remove-all-btn" id="backgroundBtn" data-click-handler="showBackgroundModal" style="visibility: hidden; pointer-events: none;" aria-hidden="true" title="Backgrounds loading...">Background</button>
                            <button class="remove-all-btn" id="listViewBtn" data-click-handler="toggleListView">List View</button>
                            <button class="remove-all-btn" id="screenshotViewBtn" data-click-handler="toggleScreenshotView" style="display: none;">Screenshot View</button>
                            <button class="remove-all-btn" id="previewBtn" data-click-handler="togglePreviewMode" title="Preview deck (read-only)">Preview</button>
                        </div>
                        <div class="deck-editor-controls-divider" role="separator" aria-hidden="true"></div>
                        <div class="deck-editor-actions" aria-label="Deck editor actions">
                            <button class="export-import-btn" id="exportBtn" data-click-handler="exportDeckAsJson" style="display: none;" title="Export deck as JSON">Export</button>
                            <button class="export-import-btn" id="importBtn" data-click-handler="importDeckFromJson" style="display: none;" title="Import deck from JSON">Import</button>
                            <button id="saveDeckButton" class="action-btn save-btn" data-click-handler="saveDeckChanges">Save</button>
                            <button class="action-btn cancel-btn" data-click-handler="closeDeckEditor">Cancel</button>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Draw Hand Section -->
            <div class="draw-hand-section" id="drawHandSection" style="display: none;">
                <div class="draw-hand-header">
                    <h4>Draw Hand</h4>
                    <button class="draw-hand-close" data-click-handler="closeDrawHand">Ã—</button>
                </div>
                <div class="draw-hand-content" id="drawHandContent">
                    <!-- Drawn cards will be displayed here -->
                </div>
            </div>
            
       <!-- Screenshot View Section -->
       <div class="screenshot-view-section" id="screenshotViewSection" style="display: none;">
           <button class="screenshot-view-close" data-click-handler="closeScreenshotView">Ã—</button>
           <div class="screenshot-view-content" id="screenshotViewContent">
               <!-- Deck cards will be displayed here in tabletop layout -->
                </div>
            </div>
            
            <div class="modal-body">
                <div class="deck-editor-layout">
                                           <!-- Left Pane: Deck List View -->
                       <div class="deck-pane">
                           <div class="deck-cards-editor" id="deckCardsEditor">
                               <!-- Deck cards will be displayed here -->
                           </div>

                       </div>
                    
                    <!-- Resizable Divider -->
                    <div class="resizable-divider" id="resizableDivider"></div>
                    
                    <!-- Right Pane: Card Selector -->
                    <div class="card-selector-pane">
                        <div class="deck-editor-search-container">
                            <input type="text" id="deckEditorSearchInput" class="deck-editor-search-input" placeholder="Search by card name, character, or type...">
                            <div id="deckEditorSearchResults" class="deck-editor-search-results" style="display: none;">
                                <!-- Search results will appear here -->
                            </div>
                        </div>
                        <div class="card-categories" id="cardCategories">
                            <!-- Card categories will be loaded here -->
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Export JSON Overlay -->
    <div id="exportJsonOverlay" class="export-overlay" style="display: none;">
        <div class="export-overlay-content">
            <div class="export-overlay-header">
                <h3>Deck Export</h3>
                <button class="export-close-btn" onclick="closeExportOverlay()">&times;</button>
            </div>
            <div class="export-overlay-body">
                <div class="json-container">
                    <div class="copy-button" onclick="copyJsonToClipboard()" title="Copy to clipboard">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                            <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                        </svg>
                    </div>
                    <pre id="exportJsonContent"></pre>
                </div>
            </div>
        </div>
    </div>

    <!-- Import JSON Overlay -->
    <div id="importJsonOverlay" class="export-overlay" style="display: none;">
        <div class="export-overlay-content">
            <div class="export-overlay-header">
                <h3>Deck Import</h3>
                <button class="export-close-btn" onclick="closeImportOverlay()">&times;</button>
            </div>
            <div class="export-overlay-body">
                <div class="json-container">
                    <textarea id="importJsonContent" class="import-json-textarea" placeholder="Paste exported deck JSON here..."></textarea>
                    <div id="importErrorMessages" class="import-error-messages" style="display: none;"></div>
                    <div class="import-actions">
                        <button id="importJsonButton" class="import-button" onclick="processImportDeck()">Import Cards</button>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    </div> <!-- Close mainContainer -->
    <script>
        
        // Cache busting: 2024-12-19 15:45:00 - Power card sorting fix
        
        // LayoutManager and utility functions moved to external files

        // Deck management functions moved to external file
        
        // Deck selection and card addition functions moved to external file
        
        // Card display functions moved to external file
        
        // Global function to ensure no filters are applied by default
        let isClearingFilters = false;
        
        // clearAllFiltersGlobally function moved to external file

        // Load database view data
        // loadDatabaseViewData function moved to external file

        // loadCharacters function moved to external file

        // loadSpecialCards function moved to external file

        // isGuestUser function moved to filter-functions.js

        // Disable "Add to Deck" buttons for guest users
        // disableAddToDeckButtons function moved to external file

        // Enhanced function to disable buttons immediately and prevent flash
        function disableAddToDeckButtonsImmediate() {
            if (isGuestUser()) {
                // Use a more aggressive approach to catch buttons as they're created
                const observer = new MutationObserver((mutations) => {
                    mutations.forEach((mutation) => {
                        if (mutation.type === 'childList') {
                            mutation.addedNodes.forEach((node) => {
                                if (node.nodeType === 1) { // Element node
                                    const buttons = node.querySelectorAll ? node.querySelectorAll('.add-to-deck-btn') : [];
                                    buttons.forEach(button => {
                                        button.disabled = true;
                                        button.style.opacity = '0.5';
                                        button.style.cursor = 'not-allowed';
                                        button.title = 'Log in to add to decks...';
                                        button.setAttribute('data-guest-disabled', 'true');
                                    });
                                    
                                    // Also check if the node itself is a button
                                    if (node.classList && node.classList.contains('add-to-deck-btn')) {
                                        node.disabled = true;
                                        node.style.opacity = '0.5';
                                        node.style.cursor = 'not-allowed';
                                        node.title = 'Log in to add to decks...';
                                        node.setAttribute('data-guest-disabled', 'true');
                                    }
                                }
                            });
                        }
                    });
                });
                
                // Start observing
                observer.observe(document.body, {
                    childList: true,
                    subtree: true
                });
                
                // Also disable existing buttons immediately
                disableAddToDeckButtons();
            }
        }

        // setupSearch function moved to external file
        // Apply all active filters


        // Clear all filters and reload all characters
        // clearAllFilters function moved to external file

        // clearFilters function moved to external file
        // Modal functionality
        // openModal, closeModal, and makeImagesClickable functions moved to external file

        // Close modal when clicking outside
        document.addEventListener('click', function(event) {
            const modal = document.getElementById('imageModal');
            if (event.target === modal) {
                closeModal();
            }
        });

        // Close modal with Escape key
        document.addEventListener('keydown', function(event) {
            if (event.key === 'Escape') {
                closeModal();
            }
        });

        // Load and display locations
        // loadLocations function moved to external file

        // Location filtering functions


        // clearLocationFilters function moved to filter-functions.js

        // Clear filter functions moved to filter-functions.js:
        // - clearSpecialCardFilters
        // - clearAdvancedUniverseFilters  
        // - clearAspectsFilters
        // - clearMissionsFilters

        // applyMissionFilters function moved to external file

        // clearEventsFilters function moved to filter-functions.js


        // clearTeamworkFilters function moved to filter-functions.js

        // clearAllyUniverseFilters function moved to filter-functions.js

        // clearTrainingFilters function moved to filter-functions.js

        // Tab switching functionality
        // Make switchTab globally available immediately
        window.switchTab = function switchTab(tabName) {
            const timestamp = new Date().toISOString().split('T')[1].split('.')[0];
            
            // Removed overly aggressive tab switching protection
            
            // Add a global flag to track if we're in the middle of a filter interaction
            if (window.isFilterInteraction) {
                
                // If we're in a filter interaction and trying to switch to characters, block it
                if (tabName === 'characters') {
                    return; // Block the tab switch
                }
            }
            
            // Also check if this is a call to switch to characters tab
            if (tabName === 'characters') {
                
                // Check if this is happening after a filter interaction
            }
            
            // Clear all filters when switching tabs
            clearAllFiltersGlobally();
            
            // Hide all tabs
            const allTabs = ['all-cards', 'characters', 'special-cards', 'advanced-universe', 'missions', 'locations', 'aspects', 'events', 'teamwork', 'ally-universe', 'training', 'basic-universe', 'power-cards'];
            allTabs.forEach(tab => {
                const tabElement = document.getElementById(tab + '-tab');
                if (tabElement) {
                    tabElement.style.display = 'none';
                }
            });
            
            // Hide search container for all tabs
            document.getElementById('search-container').style.display = 'none';
            
            // Remove active class from all buttons
            document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
            
            // Add active class to the selected tab button
            const selectedButton = document.querySelector(`[data-tab="${tabName}"]`);
            if (selectedButton) {
                selectedButton.classList.add('active');
            }
            
            // Show selected tab
            const selectedTab = document.getElementById(tabName + '-tab');
            if (selectedTab) {
                selectedTab.style.display = 'block';
            } else {
                console.error('Tab element not found:', tabName + '-tab');
            }
            
            // Update search placeholder for all tabs
            const searchInput = document.getElementById('search-input');
            if (tabName === 'characters') {
                searchInput.placeholder = 'Search characters by name or abilities...';
            } else if (tabName === 'special-cards') {
                searchInput.placeholder = 'Search special cards by name, character, or effect...';
            } else if (tabName === 'advanced-universe') {
                searchInput.placeholder = 'Search advanced universe by name, character, or effect...';
            } else if (tabName === 'locations') {
                searchInput.placeholder = 'Search locations by name or abilities...';
            } else if (tabName === 'aspects') {
                searchInput.placeholder = 'Search aspects by name, type, or effect...';
            } else if (tabName === 'missions') {
                searchInput.placeholder = 'Search missions by name or mission set...';
            } else if (tabName === 'events') {
                searchInput.placeholder = 'Search events by name, mission set, or effect...';
            } else if (tabName === 'teamwork') {
                searchInput.placeholder = 'Search teamwork by requirements or effects...';
            } else if (tabName === 'ally-universe') {
                searchInput.placeholder = 'Search allies by name, stat, or text...';
            } else if (tabName === 'training') {
                searchInput.placeholder = 'Search training by name or types...';
            } else if (tabName === 'basic-universe') {
                searchInput.placeholder = 'Search basic universe by name, type, or bonus...';
            } else if (tabName === 'power-cards') {
                searchInput.placeholder = 'Search power cards by type or value...';
            }
            
            
            // Update search functionality and reload data based on tab
            if (tabName === 'all-cards') {
                // Hide search container for All tab
                document.getElementById('search-container').style.display = 'none';
                // Load and display all cards
                if (typeof loadAndDisplayAllCards === 'function') {
                    loadAndDisplayAllCards();
                } else {
                    console.warn('loadAndDisplayAllCards function not available');
                }
            } else if (tabName === 'characters') {
                setupSearch();
                loadCharacters();
            } else if (tabName === 'special-cards') {
                setupSpecialCardSearch();
                loadSpecialCards();
            } else if (tabName === 'advanced-universe') {
                setupAdvancedUniverseSearch();
                loadAdvancedUniverse();
            } else if (tabName === 'locations') {
                setupLocationSearch();
                loadLocations();
            } else if (tabName === 'aspects') {
                setupAspectSearch();
                loadAspects();
            } else if (tabName === 'missions') {
                setupMissionSearch();
                loadMissions();
            } else if (tabName === 'events') {
                setupEventSearch();
                loadEvents();
            } else if (tabName === 'teamwork') {
                setupTeamworkSearch();
                loadTeamwork();
            } else if (tabName === 'ally-universe') {
                setupAllyUniverseSearch();
                loadAllyUniverse();
            } else if (tabName === 'training') {
                setupTrainingSearch();
                loadTraining();
            } else if (tabName === 'basic-universe') {
                setupBasicUniverseSearch();
                loadBasicUniverse();
            } else if (tabName === 'power-cards') {
                setupPowerCardsSearch();
                loadPowerCards();
            }
            
            // Disable "Add to Deck" buttons for guest users immediately
            disableAddToDeckButtonsImmediate();
        }

        // Location search functionality
        // setupLocationSearch function moved to external file

        // setupAspectSearch function moved to external file

        // setupAdvancedUniverseSearch function moved to external file

        // Teamwork search functionality
        // setupTeamworkSearch function moved to external file

        // setupSpecialCardSearch function moved to external file

        // loadMissions, loadEvents, loadAspects, loadAdvancedUniverse, loadTeamwork, displayTeamwork,
        // loadAllyUniverse, displayAllyUniverse, loadTraining, displayTraining, loadBasicUniverse,


        // Initialize page
        // Authentication functions
        let currentUser = null;
        
        // Check for readOnly=true parameter - but don't apply read-only mode class yet
        // Security: We need to verify deck ownership first in loadDeckForEditing()
        const urlParams = new URLSearchParams(window.location.search);
        const isReadOnlyFromQuery = urlParams.get('readonly') === 'true';
        
        // Note: Read-only mode class will be applied in loadDeckForEditing() after ownership verification
        
        // Show/hide Read-Only badge based on read-only mode
        window.updateReadOnlyBadge = function() {
            const readOnlyBadge = document.getElementById('readOnlyBadge');
            if (readOnlyBadge) {
                if (document.body.classList.contains('read-only-mode')) {
                    readOnlyBadge.style.display = 'inline-block';
                } else {
                    readOnlyBadge.style.display = 'none';
                }
            }
        }

        // Update Save button state based on read-only mode and user status
        window.updateSaveButtonState = function() {
            const saveButton = document.getElementById('saveDeckButton');
            if (saveButton) {
                // SECURITY: Check for read-only mode first
                if (document.body.classList.contains('read-only-mode')) {
                    // Disable Save button in read-only mode
                    saveButton.disabled = true;
                    saveButton.style.opacity = '0.5';
                    saveButton.style.cursor = 'not-allowed';
                    saveButton.title = 'Save is disabled in read-only mode';
                    saveButton.style.display = 'block';
                } else if (isGuestUser()) {
                    // Disable Save button for guest users
                    saveButton.disabled = true;
                    saveButton.style.opacity = '0.5';
                    saveButton.style.cursor = 'not-allowed';
                    saveButton.title = 'Guests cannot save edits';
                    saveButton.style.display = 'block';
                } else {
                    // Enable Save button for regular users in edit mode
                    saveButton.disabled = false;
                    saveButton.style.opacity = '1';
                    saveButton.style.cursor = 'pointer';
                    saveButton.title = '';
                    saveButton.style.display = 'block';
                }
            }
        }
        
        // Update badge and Save button state on page load
        updateReadOnlyBadge();
        updateSaveButtonState();
        
        // Add global event listener to catch any clicks that might trigger tab switches
        document.addEventListener('click', function(event) {
            if (window.isFilterInteraction) {
                if (event.target.onclick && event.target.onclick.toString().includes('switchTab')) {
                    console.log('onclick:', event.target.onclick.toString());
                }
            }
        });
        
        // Add event listeners to catch any page navigation or refresh events
        window.addEventListener('beforeunload', function(event) {
            if (window.isFilterInteraction) {
                // Page is about to unload during filter interaction
            }
        });
        
        // Add DOM observer to catch any changes to the characters tab
        const charactersTab = document.getElementById('characters-tab');
        if (charactersTab) {
            const observer = new MutationObserver(function(mutations) {
                mutations.forEach(function(mutation) {
                    if (mutation.type === 'attributes' && mutation.attributeName === 'style') {
                        // characters-tab style changed
                    }
                });
            });
            observer.observe(charactersTab, { 
                attributes: true, 
                attributeOldValue: true,
                attributeFilter: ['style']
            });
        }
        
        window.addEventListener('popstate', function(event) {
            if (window.isFilterInteraction) {
                // Browser back/forward button pressed during filter interaction
            }
        });
        
        // Add event listener to catch any form submissions
        document.addEventListener('submit', function(event) {
            if (window.isFilterInteraction) {
                // Form submission during filter interaction
                event.preventDefault();
                event.stopPropagation();
                return false;
            }
        });
        
        // Add event listener to catch any navigation events
        window.addEventListener('beforeunload', function(event) {
            if (window.isFilterInteraction) {
                // Page navigation during filter interaction
                event.preventDefault();
                event.returnValue = '';
                return '';
            }
        });
        
        // Add event listener to catch any hash changes
        window.addEventListener('hashchange', function(event) {
            if (window.isFilterInteraction) {
                // Hash change during filter interaction
                event.preventDefault();
                return false;
            }
        });
        
        // Global fetch interceptor to handle 401 responses (session expired)
        // This ensures login modal is shown whenever session expires during any API call
        const originalFetch = window.fetch;
        window.fetch = async function(...args) {
            const response = await originalFetch.apply(this, args);
            
            // Check for 401 Unauthorized responses
            if (response.status === 401) {
                // Session expired - clear user and show login modal
                if (window.authService) {
                    window.authService.currentUser = null;
                    window.authService.clearStoredUser();
                    await window.authService.showLoginModal();
                } else if (typeof showLoginModal === 'function') {
                    await showLoginModal();
                } else if (typeof window.showLoginModal === 'function') {
                    await window.showLoginModal();
                }
            }
            
            return response;
        };
        
        // Check for stored user immediately to prevent any flash
        (function() {
            const storedUser = getCurrentUser();
            if (storedUser) {
                currentUser = storedUser;
                // Hide login modal immediately if we have a stored user
                document.addEventListener('DOMContentLoaded', function() {
                    const loginModal = document.getElementById('loginModal');
                    if (loginModal) {
                        loginModal.style.display = 'none';
                    }
                });
            }
        })();

        // Use authentication service for authentication
        // checkAuthentication function moved to external file

        // showLoginModal function moved to external file

        // showMainApp function moved to external file

        // loadMainAppDataInBackground function moved to external file

        // login function moved to external file

        // logout function moved to external file

        // showLoginError function moved to external file

        // hideLoginError function moved to external file
        // loadUserData function moved to external file
        // loadGlobalNav function moved to external file

        document.addEventListener('DOMContentLoaded', async () => {
            try {
                // Load global navigation first
                await loadGlobalNav();
                
                const authResult = await checkAuthentication();
                currentUser = authResult.currentUser; // Update global currentUser after checkAuthentication
                window.currentUser = currentUser; // Also set on window for modules to access

                // Initialize ViewManager
                viewManager.initialize();

                // Update user welcome message and show/hide Create User button based on role
                if (typeof updateUserWelcome === 'function') {
                    updateUserWelcome();
                }

                if (authResult.isAuthenticated) {
                    // Ensure Collection button visibility is updated after authentication
                    if (typeof updateUserWelcome === 'function') {
                        updateUserWelcome();
                    }
                    if (authResult.deckId) {
                        // Going directly to deck editor - skip showing main app to avoid flash
                        
                        // Ensure database view is hidden to prevent flash
                        const databaseView = document.getElementById('database-view');
                        if (databaseView) {
                            databaseView.style.display = 'none';
                        }
                        
                        // Read-only mode removed - now handled by backend flag
                        
                        // Add guest class if user is a guest
                        if (currentUser && currentUser.role === 'GUEST') {
                            document.body.classList.add('guest-user');
                        }
                        
                        // Load main app data in background (without showing the UI) for when user navigates back
                        loadMainAppDataInBackground();
                        
                        // Check if readonly=true parameter is set - this takes precedence
                        const urlParams = new URLSearchParams(window.location.search);
                        const isReadOnlyFromQuery = urlParams.get('readonly') === 'true';
                        
                        await loadDeckForEditing(authResult.deckId, authResult.urlUserId, isReadOnlyFromQuery);
                        showDeckEditor();
                    } else {
                        // No deck ID - show main app normally
                        showMainApp(); // This will load general app data (characters, etc.)
                    }
                } else {
                    await showLoginModal();
                }
            } catch (error) {
                console.error('âŒ Error during page initialization:', error);
                // Fallback: show login modal if initialization fails
                await showLoginModal();
            }
            
            // Login form and guest login button event listeners are now handled by login.js component
            
            // Logout button event listener
            document.getElementById('logoutBtn').addEventListener('click', logout);
            
            // Load data only if authenticated
            if (currentUser) {
                // Check if we're on the collection route
                const isCollectionRoute = window.location.pathname.includes('/users/') && window.location.pathname.includes('/collection');
                // Check if we're on the deck builder route
                const isDeckBuilderRoute = window.location.pathname.includes('/users/') && window.location.pathname.includes('/decks');
                
                if (isCollectionRoute && currentUser.role === 'ADMIN') {
                    // Start in collection view
                    document.getElementById('database-view').style.display = 'none';
                    document.getElementById('deck-builder').style.display = 'none';
                    document.getElementById('collection-view').style.display = 'block';
                    document.getElementById('databaseViewBtn').classList.remove('active');
                    document.getElementById('deckBuilderBtn').classList.remove('active');
                    const collectionBtn = document.getElementById('collectionViewBtn');
                    if (collectionBtn) collectionBtn.classList.add('active');
                    // Initialize collection view
                    if (typeof initializeCollectionView === 'function') {
                        initializeCollectionView();
                    }
                } else if (isDeckBuilderRoute) {
                    // Start in deck builder view
                    document.getElementById('database-view').style.display = 'none';
                    document.getElementById('deck-builder').style.display = 'block';
                    document.getElementById('collection-view').style.display = 'none';
                    document.getElementById('databaseViewBtn').classList.remove('active');
                    document.getElementById('deckBuilderBtn').classList.add('active');
                    const collectionBtn = document.getElementById('collectionViewBtn');
                    if (collectionBtn) collectionBtn.classList.remove('active');
                    
                } else {
                    // Start in database view
                    document.getElementById('database-view').style.display = 'block';
                    document.getElementById('deck-builder').style.display = 'none';
                    document.getElementById('collection-view').style.display = 'none';
                    document.getElementById('databaseViewBtn').classList.add('active');
                    document.getElementById('deckBuilderBtn').classList.remove('active');
                    const collectionBtn = document.getElementById('collectionViewBtn');
                    if (collectionBtn) collectionBtn.classList.remove('active');
                    
                    // Load All tab if it's the active tab
                    setTimeout(() => {
                        const allTabButton = document.querySelector('[data-tab="all-cards"]');
                        if (allTabButton && allTabButton.classList.contains('active')) {
                            if (typeof switchTab === 'function') {
                                switchTab('all-cards');
                            }
                        }
                    }, 100);
                }
                
                // Show database statistics in initial database view
                const databaseStats = document.getElementById('database-stats');
                const deckStats = document.getElementById('deck-stats');
                if (databaseStats) databaseStats.style.display = 'grid';
                if (deckStats) deckStats.style.display = 'none';
                
                // Load decks immediately for better user experience
                loadDecks();
                
                // Load other data in background (non-blocking)
                setTimeout(() => {
                    loadAspects();
                    loadEvents();
                    loadTeamwork();
                    loadUserDecks(); // Load user decks for Add to Deck functionality
                    loadAllyUniverse();
                    loadTraining();
                    loadBasicUniverse();
                    loadPowerCards();
                    setupSearch();
                }, 100); // Small delay to let decks load first
            }
            
            // Add location filter event listeners with comprehensive event prevention
            const locationThreatMin = document.getElementById('location-threat-min');
            const locationThreatMax = document.getElementById('location-threat-max');
            
            
            locationThreatMin.addEventListener('input', (e) => {
                applyLocationFilters();
            });
            locationThreatMax.addEventListener('input', (e) => {
                applyLocationFilters();
            });
            
            // Prevent form submission and unwanted navigation
            locationThreatMin.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    e.stopPropagation();
                    applyLocationFilters();
                }
            });
            
            locationThreatMax.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    e.stopPropagation();
                    applyLocationFilters();
                }
            });
            
            // Prevent click events from bubbling up and causing navigation (but allow normal input behavior)
            locationThreatMin.addEventListener('click', (e) => {
                e.stopPropagation(); // Only stop propagation, don't prevent default
            });
            
            locationThreatMax.addEventListener('click', (e) => {
                e.stopPropagation(); // Only stop propagation, don't prevent default
            });
            
            // Add event listeners for spinner arrows (mousedown/up events) - only prevent on spinner arrows
            locationThreatMin.addEventListener('mousedown', (e) => {
                // Only prevent if it's on the spinner arrows (not the input field itself)
                if (e.target !== locationThreatMin) {
                    e.preventDefault();
                    e.stopPropagation();
                    e.stopImmediatePropagation();
                } else {
                    e.stopPropagation(); // Just stop propagation for the input field
                }
            });
            
            locationThreatMax.addEventListener('mousedown', (e) => {
                // Only prevent if it's on the spinner arrows (not the input field itself)
                if (e.target !== locationThreatMax) {
                    e.preventDefault();
                    e.stopPropagation();
                    e.stopImmediatePropagation();
                } else {
                    e.stopPropagation(); // Just stop propagation for the input field
                }
            });
            
            // Add event listeners for mouseup events (spinner arrows) - only prevent on spinner arrows
            locationThreatMin.addEventListener('mouseup', (e) => {
                // Only prevent if it's on the spinner arrows (not the input field itself)
                if (e.target !== locationThreatMin) {
                    e.preventDefault();
                    e.stopPropagation();
                    e.stopImmediatePropagation();
                } else {
                    e.stopPropagation(); // Just stop propagation for the input field
                }
            });
            
            locationThreatMax.addEventListener('mouseup', (e) => {
                // Only prevent if it's on the spinner arrows (not the input field itself)
                if (e.target !== locationThreatMax) {
                    e.preventDefault();
                    e.stopPropagation();
                    e.stopImmediatePropagation();
                } else {
                    e.stopPropagation(); // Just stop propagation for the input field
                }
            });
            
            // Add event listeners for focus events
            locationThreatMin.addEventListener('focus', (e) => {
                e.stopPropagation();
            });
            
            locationThreatMax.addEventListener('focus', (e) => {
                e.stopPropagation();
            });
            
            // Prevent any form submission or navigation
            locationThreatMin.addEventListener('change', (e) => {
                e.preventDefault();
                e.stopPropagation();
                applyLocationFilters();
            });
            
            locationThreatMax.addEventListener('change', (e) => {
                e.preventDefault();
                e.stopPropagation();
                applyLocationFilters();
            });
            
            // Update all stats after loading data
            // Make images clickable after they are loaded
            setTimeout(makeImagesClickable, 1000);
        });

        // ===== DECK SELECTION / DECK TILE FUNCTIONS =====
        // - /js/deck-selection/deckTileImages.js
        // - /js/deck-selection/deckTileTimestamps.js
        // - /js/deck-selection/deckTilesRenderer.js
        // - /js/deck-selection/deckTileMenu.js
        // - /js/deck-selection/index.js
        //
        // Keep a stable init hook for future needs.
        if (window.DeckSelection && typeof window.DeckSelection.init === 'function') {
            window.DeckSelection.init();
        }

        // updateDeckStats function moved to filter-functions.js

        // Modal functions
        async function showCreateDeckModal() {
            document.getElementById('createDeckModal').style.display = 'flex';
            document.getElementById('deckName').focus();
            
            // Load characters into dropdown
            await loadCharactersForDeckCreation();
        }

        async function loadCharactersForDeckCreation() {
            try {
                const response = await fetch('/api/characters');
                const result = await response.json();
                
                if (result.success && result.data) {
                    const characters = result.data;
                    const characterSelect = document.getElementById('characterSelect');
                    characterSelect.innerHTML = '<option value="">Select a character to add...</option>';
                    
                    characters.forEach(character => {
                        const option = document.createElement('option');
                        option.value = character.id;
                        option.textContent = character.name;
                        characterSelect.appendChild(option);
                    });
                }
                
                // Clear selected characters
                document.getElementById('selectedCharacters').innerHTML = '';
            } catch (error) {
                console.error('Error loading characters:', error);
            }
        }

        // closeCreateDeckModal function moved to external file

        // Character selection functionality
        let selectedCharacterIds = [];

        // addCharacterToDeck function moved to external file

        // removeCharacterFromDeck function moved to external file

        // Add event listener for character dropdown
        document.addEventListener('DOMContentLoaded', function() {
            const characterSelect = document.getElementById('characterSelect');
            if (characterSelect) {
                characterSelect.addEventListener('change', addCharacterToDeck);
            }
        });

        // Create deck form submission
        document.getElementById('createDeckForm').addEventListener('submit', async (e) => {
            e.preventDefault();
            
            const name = document.getElementById('deckName').value.trim();
            
            if (!name) return;

            try {
                const response = await fetch('/api/decks', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    credentials: 'include',
                    body: JSON.stringify({ 
                        name, 
                        description: '',
                        characters: selectedCharacterIds 
                    })
                });

                const data = await response.json();
                if (data.success) {
                    closeCreateDeckModal();
                    loadDecks(); // Refresh the deck list
                    showNotification('Deck created successfully!', 'success');
                } else {
                    showNotification('Failed to create deck: ' + data.error, 'error');
                }
            } catch (error) {
                console.error('Error creating deck:', error);
                showNotification('Failed to create deck', 'error');
            }
        });

        // editDeck function moved to external file

        // viewDeck function moved to external file

        // deleteDeck function moved to external file

        // Notification system
        // showNotification function moved to external file

        // Add notification animations to CSS
        const style = document.createElement('style');
        style.textContent = `
            @keyframes slideIn {
                from { transform: translateX(100%); opacity: 0; }
                to { transform: translateX(0); opacity: 1; }
            }
            @keyframes slideOut {
                from { transform: translateX(0); opacity: 1; }
                to { transform: translateX(100%); opacity: 0; }
            }
        `;
        document.head.appendChild(style);

        // ===== NEW MODAL FUNCTIONS =====

        // showViewDeckModal, closeViewDeckModal, showAddCardsModal, closeAddCardsModal functions moved to external file
        // Ensure consistent two-pane layout
        // ensureTwoPaneLayout function moved to filter-functions.js
        
        // Add window resize listener for layout maintenance (throttled)
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                // Only fix layout if it appears broken
                const layout = document.querySelector('.deck-editor-layout');
                if (layout && window.getComputedStyle(layout).flexDirection !== 'row') {
                    ensureTwoPaneLayout();
                }
            }, 250);
        });
        

        // Load deck details and display cards
        async function loadDeckDetails(deckId) {
            
            const layout = document.querySelector('.deck-editor-layout');
            const deckPane = document.querySelector('.deck-pane');
            const cardSelectorPane = document.querySelector('.card-selector-pane');
            
            try {
                const response = await fetch(`/api/decks/${deckId}`, {
                    credentials: 'include'
                });
                const data = await response.json();
                
                if (data.success) {
                    const deck = data.data;
                    
                    // Update modal title and metadata
                    document.getElementById('viewDeckTitle').textContent = deck.metadata.name;
                    document.getElementById('viewDeckCreated').textContent = new Date(deck.metadata.created).toLocaleDateString();
                    document.getElementById('viewDeckModified').textContent = new Date(deck.metadata.lastModified).toLocaleDateString();
                    document.getElementById('viewDeckCardCount').textContent = calculateTotalCardCount(deck.cards || []);
                    
                    // Display deck cards
                    displayDeckCards(deck.cards);
                } else {
                    showNotification('Failed to load deck details: ' + data.error, 'error');
                }
            } catch (error) {
                console.error('Error loading deck details:', error);
                showNotification('Failed to load deck details', 'error');
            }
        }

        async function displayDeckCards(cards) {
            const deckCardsList = document.getElementById('deckCardsList');
            
            if (cards.length === 0) {
                deckCardsList.innerHTML = `
                    <div style="text-align: center; color: #bdc3c7; padding: 20px;">
                        <p>No cards in this deck yet.</p>
                        <p>Click "Add Cards" to get started!</p>
                    </div>
                `;
                return;
            }

            // Load character data for character cards
            let characterMap = {};
            const characterCards = cards.filter(card => card.type === 'character');
            if (characterCards.length > 0) {
                try {
                    const response = await fetch('/api/characters');
                    const result = await response.json();
                    if (result.success) {
                        characterMap = result.data.reduce((map, char) => {
                            map[char.id] = char;
                            return map;
                        }, {});
                    }
                } catch (error) {
                    console.error('Error loading character data:', error);
                }
            }

            deckCardsList.innerHTML = cards.map(card => {
                let cardImage = '';
                let cardName = getCardName(card);
                
                if (card.type === 'character') {
                    // Direct lookup using UUID
                    const character = window.availableCardsMap.get(card.cardId);
                    if (character && character.image) {
                        const imagePath = getCardImagePath(character, 'character');
                        cardImage = `<div class="deck-card-image" style="background-image: url('${imagePath}')" title="${character.name}"></div>`;
                        cardName = character.name;
                    }
                }
                
                return `
                    <div class="deck-card-item">
                        ${cardImage}
                        <div class="deck-card-info">
                            <div class="deck-card-name">${cardName}</div>
                            <div class="deck-card-type">${formatCardType(card.type)}</div>
                        </div>
                        <div class="deck-card-quantity">Ã—${card.quantity}</div>
                        <div class="deck-card-actions">
                            <div class="quantity-controls">
                                <button class="quantity-btn" onclick="changeCardQuantity('${card.id}', -1)">-</button>
                                <span>${card.quantity}</span>
                                <button class="quantity-btn" onclick="changeCardQuantity('${card.id}', 1)">+</button>
                            </div>
                            <button class="quantity-btn danger" onclick="removeCardFromDeck('${card.id}')">Remove</button>
                        </div>
                    </div>
                `;
            }).join('');
        }

        // getCardName, formatCardType functions moved to external file

        async function removeCardFromDeck(cardId) {
            
            const layout = document.querySelector('.deck-editor-layout');
            const deckPane = document.querySelector('.deck-pane');
            const cardSelectorPane = document.querySelector('.card-selector-pane');
            
            if (!currentDeckId) return;
            
            if (confirm('Are you sure you want to remove this card from the deck?')) {
                try {
                    const response = await fetch(`/api/decks/${currentDeckId}/cards`, {
                        method: 'DELETE',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        credentials: 'include',
                        body: JSON.stringify({
                            cardType: 'character', // TODO: Get actual card type
                            cardId: cardId,
                            quantity: 1
                        })
                    });

                    const data = await response.json();
                    if (data.success) {
                        // Reload deck details
                        loadDeckDetails(currentDeckId);
                        // Refresh deck list
                        loadDecks();
                        showNotification('Card removed from deck', 'success');
                        
                        // Check layout after removal
                        setTimeout(() => {
                            // Only ensure layout if we detect it's broken
                            const currentLayout = document.querySelector('.deck-editor-layout');
                            if (currentLayout && window.getComputedStyle(currentLayout).flexDirection !== 'row') {
                                ensureTwoPaneLayout();
                            }
                        }, 100);
                    } else {
                        showNotification('Failed to remove card: ' + data.error, 'error');
                    }
                } catch (error) {
                    console.error('Error removing card:', error);
                    showNotification('Failed to remove card', 'error');
                }
            }
        }

        // Card search functionality
        async function searchCards() {
            const cardType = document.getElementById('cardTypeFilter').value;
            const searchTerm = document.getElementById('cardSearchInput').value.toLowerCase();
            
            try {
                let cards = [];
                
                // Search based on card type
                if (cardType === 'character' || cardType === '') {
                    const response = await fetch('/api/characters');
                    const data = await response.json();
                    if (data.success) {
                        cards.push(...data.data.map(card => ({
                            ...card,
                            type: 'character',
                            displayName: card.name
                        })));
                    }
                }
                
                if (cardType === 'location' || cardType === '') {
                    const response = await fetch('/api/locations');
                    const data = await response.json();
                    if (data.success) {
                        cards.push(...data.data.map(card => ({
                            ...card,
                            type: 'location',
                            displayName: card.name
                        })));
                    }
                }
                
                if (cardType === 'special' || cardType === '') {
                    const response = await fetch('/api/special-cards');
                    const data = await response.json();
                    if (data.success) {
                        cards.push(...data.data.map(card => ({
                            ...card,
                            type: 'special',
                            displayName: card.name
                        })));
                    }
                }
                
                // Filter by search term if provided
                if (searchTerm) {
                    cards = cards.filter(card => 
                        card.displayName.toLowerCase().includes(searchTerm)
                    );
                }
                
                // Limit results to first 50 for performance
                cards = cards.slice(0, 50);
                
                displayCardSearchResults(cards);
            } catch (error) {
                console.error('Error searching cards:', error);
                document.getElementById('cardResults').innerHTML = '<div class="error">Error searching cards</div>';
            }
        }

        // displayCardSearchResults function moved to external file

        // Global variables for deck management
        let currentDeckId = null;
        let currentDeckData = null;
        window.deckEditorCards = []; // Working copy of deck cards
        window.availableCardsMap = new Map(); // Cache for available cards data
        // KO state is managed by SimulateKO module - don't initialize here, let the module handle it
        // window.koCharacters will be created by SimulateKO.init()
        let deckEditorExpansionState = {}; // Track expansion state of deck type sections
        let characterGroupExpansionState = {}; // Track expansion state of character groups within special cards
        let powerCardsSortMode = 'value'; // Track power cards sort mode: 'type' or 'value' (default: 'value')
        let lastAddedCardType = null; // Track which card type was just added


        // Deck validation rules based on Overpower rules
        const DECK_RULES = {
            MIN_DECK_SIZE: 51,
            MIN_DECK_SIZE_WITH_EVENTS: 56,
            EXACT_CHARACTERS: 4,
            MAX_TOTAL_THREAT: 76,
            MAX_COPIES_ONE_PER_DECK: 1,
            EXACT_MISSION_CARDS: 7,
            MAX_LOCATIONS: 1
        };

        // toggleDrawHand, closeDrawHand functions moved to external file

        // toggleScreenshotView, closeScreenshotView functions moved to external file


        class ViewManager {
            constructor() {
                // Default to tile view initially - will be updated during initialization
                this.currentView = 'tile';
                this.deckCardsEditor = null;
                this.listViewBtn = null;
            }

            initialize() {
                this.deckCardsEditor = document.getElementById('deckCardsEditor');
                this.listViewBtn = document.getElementById('listViewBtn');
                
                // All users now start with Card View as the default
                this.currentView = 'card';
                this.setInitialView();
            }
            
            setInitialView() {
                // Set button text for all users (Card View â†’ List View â†’ Tile View)
                if (this.listViewBtn) {
                    this.listViewBtn.textContent = 'List View';
                }
            }
            
            async applyInitialView() {
                // Apply the initial view based on currentView setting
                if (this.currentView === 'card') {
                    await this.switchToCardView();
                } else {
                    // Default to tile view
                    await this.switchToTileView();
                }
            }

            async switchToTileView() {
                this.currentView = 'tile';
                
                // Disconnect layout observer when switching to tile view
                if (layoutObserver) {
                    layoutObserver.disconnect();
                    layoutObserver = null;
                }
                
                if (this.deckCardsEditor) {
                    this.deckCardsEditor.classList.remove('list-view');
                    this.deckCardsEditor.classList.remove('card-view');
                }
                
                if (this.listViewBtn) {
                    // All users now have the same view cycling: Card View â†’ List View â†’ Tile View â†’ Card View
                    this.listViewBtn.textContent = 'Card View';
                }
                
                // Use the original function to maintain exact behavior
                await displayDeckCardsForEditing();
                
                // Force layout recalculation to ensure tiles stretch properly
                // This fixes the issue where tiles don't take up full width initially
                if (this.deckCardsEditor) {
                    // Wait for DOM to be fully updated
                    await new Promise(resolve => requestAnimationFrame(resolve));
                    
                    // CRITICAL FIX: Ensure two-column layout is properly set up
                    // First, ensure the two-column class is present
                    if (!this.deckCardsEditor.classList.contains('two-column')) {
                        this.deckCardsEditor.classList.add('two-column');
                    }
                    
                    // Ensure columns exist - create them if they don't
                    let deckColumns = this.deckCardsEditor.querySelectorAll('.deck-column');
                    if (deckColumns.length === 0) {
                        // Columns don't exist yet - create them
                        if (typeof createTwoColumnLayout === 'function') {
                            createTwoColumnLayout();
                            // Re-query after creation
                            deckColumns = this.deckCardsEditor.querySelectorAll('.deck-column');
                        }
                    }
                    
                    // Force columns to stretch properly
                    if (deckColumns.length > 0) {
                        // Ensure deckCardsEditor is set up as flex container
                        this.deckCardsEditor.style.display = 'flex';
                        this.deckCardsEditor.style.flexDirection = 'row';
                        this.deckCardsEditor.style.gap = '20px';
                        this.deckCardsEditor.style.alignItems = 'flex-start';
                        
                        deckColumns.forEach(column => {
                            // Force column to stretch by setting flex properties directly
                            column.style.flex = '1 1 0%';
                            column.style.display = 'flex';
                            column.style.flexDirection = 'column';
                            column.style.gap = '20px';
                            column.style.width = '';
                            column.style.maxWidth = '';
                            column.style.minWidth = '0';
                            column.style.flexBasis = '0%';
                            
                            // Force reflow
                            void column.offsetWidth;
                            void column.offsetHeight;
                        });
                        
                        // Force deckCardsEditor reflow to ensure it calculates column widths
                        void this.deckCardsEditor.offsetWidth;
                        void this.deckCardsEditor.offsetHeight;
                    }
                    
                    // Force grid containers to recalculate by accessing their layout properties
                    const gridContainers = this.deckCardsEditor.querySelectorAll('.deck-type-cards');
                    gridContainers.forEach(container => {
                        // Force reflow by accessing layout properties
                        void container.offsetWidth;
                        void container.offsetHeight;
                        // Force grid recalculation by temporarily toggling display
                        const originalDisplay = window.getComputedStyle(container).display;
                        if (originalDisplay === 'grid') {
                            container.style.display = 'block';
                            void container.offsetHeight; // Force reflow
                            container.style.display = 'grid';
                            void container.offsetHeight; // Force reflow again
                        }
                    });
                    
                    // Force container reflow
                    void this.deckCardsEditor.offsetWidth;
                    void this.deckCardsEditor.offsetHeight;
                    
                    // Wait another frame for layout to settle
                    await new Promise(resolve => requestAnimationFrame(resolve));
                    
                    // Access tile layout properties to ensure they stretch
                    const tiles = this.deckCardsEditor.querySelectorAll('.deck-card-editor-item.preview-view');
                    tiles.forEach(tile => {
                        void tile.offsetWidth;
                    });
                    
                    // Trigger a synthetic resize event to force any resize listeners to recalculate
                    window.dispatchEvent(new Event('resize'));
                    
                    // One more frame to ensure everything is settled
                    await new Promise(resolve => requestAnimationFrame(resolve));
                    
                    // Final check: Force columns to stretch one more time after everything settles
                    if (deckColumns.length > 0) {
                        deckColumns.forEach(column => {
                            void column.offsetWidth;
                            void column.offsetHeight;
                        });
                    }
                    
                    // Trigger layout update to ensure proper column widths
                    // This calls updateDeckLayout which handles the two-column logic
                    if (typeof updateDeckLayout === 'function') {
                        const deckPane = document.querySelector('.deck-pane');
                        if (deckPane) {
                            const layout = document.querySelector('.deck-editor-layout');
                            if (layout) {
                                const deckWidth = deckPane.getBoundingClientRect().width;
                                const layoutWidth = layout.getBoundingClientRect().width;
                                updateDeckLayout(deckWidth, layoutWidth);
                            }
                        }
                    }
                }
            }

            async switchToListView() {
                this.currentView = 'list';
                
                if (this.deckCardsEditor) {
                    this.deckCardsEditor.classList.add('list-view');
                    this.deckCardsEditor.classList.remove('card-view');
                }
                
                if (this.listViewBtn) {
                    this.listViewBtn.textContent = 'Tile View';
                }
                
                // Use the original function to maintain exact behavior
                renderDeckCardsListView();
                
                // Set up layout observer for list view
                setupLayoutObserver();
                
                // Force 2-column layout for list view
                setTimeout(() => {
                    enforceTwoColumnLayoutInListView();
                }, 10);
                
                // Force immediate layout fix for list view
                setTimeout(() => {
                    const listItems = this.deckCardsEditor.querySelectorAll('.deck-list-item');
                    listItems.forEach(item => {
                        item.style.display = 'flex';
                        item.style.flexDirection = 'row';
                        item.style.flexWrap = 'nowrap';
                        item.style.width = '100%';
                        item.style.minWidth = '0';
                        item.style.boxSizing = 'border-box';
                        item.style.alignItems = 'center';
                        item.style.justifyContent = 'flex-start';
                    });
                    this.deckCardsEditor.offsetHeight; // Trigger reflow
                    
                    // Additional enforcement after a short delay
                    setTimeout(() => {
                        const listItems = this.deckCardsEditor.querySelectorAll('.deck-list-item');
                        listItems.forEach(item => {
                            item.style.display = 'flex';
                            item.style.flexDirection = 'row';
                            item.style.flexWrap = 'nowrap';
                            item.style.width = '100%';
                            item.style.minWidth = '100%';
                            item.style.boxSizing = 'border-box';
                            item.style.alignItems = 'center';
                            item.style.justifyContent = 'flex-start';
                        });
                    }, 50);
                }, 10);
            }

            async switchToCardView() {
                this.currentView = 'card';
                
                // Disconnect layout observer when switching to card view
                if (layoutObserver) {
                    layoutObserver.disconnect();
                    layoutObserver = null;
                }
                
                if (this.deckCardsEditor) {
                    this.deckCardsEditor.classList.remove('list-view');
                    this.deckCardsEditor.classList.remove('two-column'); // Remove two-column class that interferes with Card View
                    this.deckCardsEditor.classList.add('card-view');
                }
                
                if (this.listViewBtn) {
                    this.listViewBtn.textContent = 'List View';
                }
                
                // Use the new card view rendering function - completely independent
                renderDeckCardsCardView();
            }

            getCurrentView() {
                return this.currentView;
            }

            isListView() {
                return this.currentView === 'list';
            }

            isTileView() {
                return this.currentView === 'tile';
            }

            isCardView() {
                return this.currentView === 'card';
            }
        }

        // Global view manager instance
        const viewManager = new ViewManager();

        // View toggle functionality - now supports three-way cycling (Card â†’ List â†’ Tile â†’ Card)
        // toggleListView, renderDeckCardsListView, toggleCardViewCategory, renderDeckCardsCardView


        // Function to enforce horizontal layout in list view

        // Draw Hand functionality has been moved to public/js/components/draw-hand.js module

        // validateDeck function moved to external file

        // calculateTotalCardCount function moved to external file

        // calculateTotalThreat function moved to external file
        
        // Function to calculate total icon counts across all cards in the deck
        // Uses the same logic as list view to determine icons for each card type
        // Only counts icons from: Special Cards, Aspect Cards, Ally Cards, Teamwork Cards, and Power Cards


        // Function to update deck title validation badge
        // updateDeckTitleValidation, toggleLimitedState functions moved to external file

        // Add event listeners for card search
        document.getElementById('cardTypeFilter').addEventListener('change', searchCards);
        document.getElementById('cardSearchInput').addEventListener('input', debounce(searchCards, 300));

        // Toggle category collapse/expand
        // toggleCategory, togglePowerCardsSort, loadPowerCardsSortMode, toggleCharacterGroup,


        // Update deck editor card count display

        // updateSpecialCardsFilter, toggleAdvancedUniverseCharacterFilter, updateAdvancedUniverseFilter,
        // togglePowerCardsCharacterFilter, updatePowerCardsFilter, toggleBasicUniverseCharacterFilter,
        // updateBasicUniverseFilter, toggleTeamworkCharacterFilter, updateTeamworkFilter,
        // toggleTrainingCharacterFilter, updateTrainingFilter, toggleAllyUniverseCharacterFilter,


        // ===== UI PREFERENCES MANAGEMENT =====

        // Load UI preferences from database


        // ===== DECK EDITOR FUNCTIONS =====

        // Deck Editor Search Functionality
        let deckEditorSearchTimeout;
        let allCardsCache = null;

        // Initialize deck editor search

        // Inline editing functions for deck title
        // startEditingTitle function moved to external file

        // saveTitleEdit function moved to external file

        // cancelTitleEdit function moved to external file

        // showDeckEditor function moved to external file

        // closeDeckEditor function moved to external file
        // Resizable divider functionality

        function initializeBlankDeck() {
            console.log('initializeBlankDeck called');
            
            // Set up blank deck data
            currentDeckData = {
                metadata: {
                    id: null,
                    name: 'New Deck',
                    description: '',
                    created: new Date().toISOString(),
                    lastModified: new Date().toISOString(),
                    cardCount: 0,
                    userId: getCurrentUser() ? (getCurrentUser().userId || getCurrentUser().id) : 'guest'
                },
                cards: []
            };
            
            window.deckEditorCards = [];
            currentDeckId = null;
            
            // Update modal title and description
            const titleElement = document.getElementById('deckEditorTitle');
            const descriptionElement = document.getElementById('deckEditorDescription');
            
            if (titleElement) {
                titleElement.textContent = 'New Deck';
            }
            
            if (descriptionElement) {
                descriptionElement.textContent = 'Click to add description';
                descriptionElement.style.display = 'block';
                descriptionElement.classList.add('placeholder');
            }
            
            // Clear any existing cards
            const deckCardsContainer = document.getElementById('deckCardsContainer');
            if (deckCardsContainer) {
                deckCardsContainer.innerHTML = '<div class="no-cards-message">No cards in this deck yet. Drag cards from the right panel to add them!</div>';
            }
            
            // Load available cards
            if (typeof loadAvailableCards === 'function') {
                loadAvailableCards();
            }
            
            // Update card count
            updateDeckCardCount();
            
            // Update deck title validation
            updateDeckTitleValidation(currentDeckData.cards || []);
                    
                    // Update power cards filter to show correct counts
                    updatePowerCardsFilter();
        }

        // loadDeckForEditing function moved to external file

        // applyCharacterBackgroundsToEditor, applyDeckEditorExpansionState, toggleDeckTypeSection,
        // toggleDeckListSection, ensureScrollContainerCanShowAllContent, ensureCollapsedHeaderIsVisible


        // Save deck expansion state to localStorage

        // Helper function to map database IDs to deck card IDs (reverse mapping)
        // Note: After UUID migration, this function is no longer needed as we'll use
        // a different approach to map between deck card IDs and database UUIDs

        async function loadAvailableCardsData() {
            try {
                const categories = [
                    { type: 'character', api: '/api/characters', nameField: 'name' },
                    { type: 'location', api: '/api/locations', nameField: 'name' },
                    { type: 'special', api: '/api/special-cards', nameField: 'name' },
                    { type: 'mission', api: '/api/missions', nameField: 'name' },
                    { type: 'event', api: '/api/events', nameField: 'name' },
                    { type: 'aspect', api: '/api/aspects', nameField: 'card_name' },
                    { type: 'advanced-universe', api: '/api/advanced-universe', nameField: 'name' },
                    { type: 'teamwork', api: '/api/teamwork', nameField: 'card_type' },
                    { type: 'ally-universe', api: '/api/ally-universe', nameField: 'card_name' },
                    { type: 'training', api: '/api/training', nameField: 'card_name' },
                    { type: 'basic-universe', api: '/api/basic-universe', nameField: 'card_name' },
                    { type: 'power', api: '/api/power-cards', nameField: 'power_type' }
                ];
                
                for (const category of categories) {
                        const response = await fetch(category.api);
                        const data = await response.json();
                        
                        if (data.success && data.data.length > 0) {
                            data.data.forEach(card => {
                                // Add the category type to the card data for easy lookup
                                card.cardType = category.type;
                                
                                // Store with database UUID format (primary key)
                                window.availableCardsMap.set(card.id, card);
                                
                                // Store with category prefix for compatibility
                                window.availableCardsMap.set(`${category.type}_${card.id}`, card);
                                
                                // Store by name for easy lookup
                                // For teamwork cards, use 'to_use' field instead of 'name'
                                if (category.type === 'teamwork') {
                                    const cardName = card.to_use || card.name;
                                    if (cardName) {
                                        window.availableCardsMap.set(cardName, card);
                                    }
                                } else {
                                    // For training, ally-universe, basic-universe, and aspects, use card_name if available
                                    if (category.type === 'training' || category.type === 'ally-universe' || category.type === 'basic-universe' || category.type === 'aspect') {
                                        const cardName = card.card_name || card.name;
                                        if (cardName) {
                                            window.availableCardsMap.set(cardName, card);
                                        }
                                    } else {
                                        if (card.name) {
                                window.availableCardsMap.set(card.name, card);
                                        }
                                    }
                                }
                                
                                // For characters, create a mapping from deck card IDs to database UUIDs
                                if (category.type === 'character') {
                                    const charMappings = {
                                        'Zeus': 'char_42',
                                        'Leonidas': 'char_22', 
                                        'Dr. Watson': 'char_11',
                                        'Sherlock Holmes': 'char_8',
                                        'Dracula': 'char_12',
                                        'Victory Harben': 'char_15'
                                    };
                                    const deckCardId = charMappings[card.name];
                                    if (deckCardId) {
                                        window.availableCardsMap.set(deckCardId, card);
                                    }
                                }
                            });
                        }
                }
            } catch (error) {
                console.error('Error loading available cards data:', error);
            }
        }
        // removeCardFromEditor, removeOneCardFromEditor, addOneCardToEditor,
        // removeAllMissionsFromDeck, removeAllCardsFromDeck, removeUnusable*,
        // addAllSpecialCardsForCharacter, addAllAdvancedUniverseCardsForCharacter


        // Function to update just the character limit status without affecting collapse state
        // updateCharacterLimitStatus, updateLocationLimitStatus, updateMissionLimitStatus,
        // getOPDKeyForDimming, updateOnePerDeckLimitStatus, shouldSpecialCardBeDisabled,
        // updateCataclysmLimitStatus, updateAssistLimitStatus, updateAmbushLimitStatus

        // KO Feature Functions - Now handled by SimulateKO module
        // Wrapper functions for backward compatibility

        // Function to update Fortification card dimming status

        async function loadAvailableCards() {
            try {
                const cardCategories = document.getElementById('cardCategories');
                
                // Save current collapse state before refreshing
                const currentCollapseState = {};
                const existingHeaders = cardCategories.querySelectorAll('.card-category-header');
                existingHeaders.forEach(header => {
                    const categoryName = header.textContent.split(' (')[0]; // Extract name without count
                    currentCollapseState[categoryName] = header.classList.contains('collapsed');
                });
                
                cardCategories.innerHTML = '<div class="drag-instructions">Loading available cards...</div>';
                
                const categories = [
                    { type: 'character', name: 'Characters', api: '/api/characters', nameField: 'name' },
                    { type: 'location', name: 'Locations', api: '/api/locations', nameField: 'name' },
                    { type: 'special', name: 'Special Cards', api: '/api/special-cards', nameField: 'name' },
                    { type: 'mission', name: 'Missions', api: '/api/missions', nameField: 'card_name' },
                    { type: 'event', name: 'Events', api: '/api/events', nameField: 'name' },
                    { type: 'aspect', name: 'Aspects', api: '/api/aspects', nameField: 'card_name' },
                    { type: 'advanced-universe', name: 'Universe: Advanced', api: '/api/advanced-universe', nameField: 'name' },
                    { type: 'teamwork', name: 'Universe: Teamwork', api: '/api/teamwork', nameField: 'card_type' },
                    { type: 'ally-universe', name: 'Universe: Ally', api: '/api/ally-universe', nameField: 'card_name' },
                    { type: 'training', name: 'Universe: Training', api: '/api/training', nameField: 'card_name' },
                    { type: 'basic-universe', name: 'Universe: Basic', api: '/api/basic-universe', nameField: 'card_name' },
                    { type: 'power', name: 'Power Cards', api: '/api/power-cards', nameField: 'power_type' }
                ];
                
                let categoriesHtml = '';
                
                for (const category of categories) {
                        const response = await fetch(category.api);
                        const data = await response.json();
                        
                        // Variables to store tile counts for header rendering
                        let characterTileCount = null;
                        let specialCardTileCount = null;
                        let powerCardTileCount = null;
                        let locationTileCount = null;
                        
                        if (data.success && data.data.length > 0) {
                            // Populate the global map for deck editor use
                            data.data.forEach(card => {
                                // Add the category type to the card data for easy lookup
                                card.cardType = category.type;
                                
                                // Store with database UUID format (primary key)
                                window.availableCardsMap.set(card.id, card);
                                
                                // Store with category prefix for compatibility
                                window.availableCardsMap.set(`${category.type}_${card.id}`, card);
                                
                                // Store by name for easy lookup
                                // For teamwork cards, use 'to_use' field instead of 'name'
                                if (category.type === 'teamwork') {
                                    const cardName = card.to_use || card.name;
                                    if (cardName) {
                                        window.availableCardsMap.set(cardName, card);
                                    }
                                } else {
                                    // For training, ally-universe, basic-universe, and aspects, use card_name if available
                                    if (category.type === 'training' || category.type === 'ally-universe' || category.type === 'basic-universe' || category.type === 'aspect') {
                                        const cardName = card.card_name || card.name;
                                        if (cardName) {
                                            window.availableCardsMap.set(cardName, card);
                                        }
                                    } else {
                                        if (card.name) {
                                window.availableCardsMap.set(card.name, card);
                                        }
                                    }
                                }
                                
                                // For characters, create a mapping from deck card IDs to database UUIDs
                                if (category.type === 'character') {
                                    const charMappings = {
                                        'Zeus': 'char_42',
                                        'Leonidas': 'char_22', 
                                        'Dr. Watson': 'char_11',
                                        'Sherlock Holmes': 'char_8',
                                        'Dracula': 'char_12',
                                        'Victory Harben': 'char_15'
                                    };
                                    const deckCardId = charMappings[card.name];
                                    if (deckCardId) {
                                        window.availableCardsMap.set(deckCardId, card);
                                    }
                                }
                            });
                            
                            let cardsHtml = '';
                            
                            if (category.type === 'character') {
                                // Special handling for characters with stats
                                const currentCharacterCount = window.deckEditorCards
                                    .filter(card => card.type === 'character')
                                    .reduce((total, card) => total + card.quantity, 0);
                                
                                const isCharacterLimitReached = currentCharacterCount >= 4;
                                
                                // Group characters by name and set (same type, name, set = same card)
                                const groups = new Map();
                                data.data.forEach(card => {
                                    const name = (card.name || '').trim();
                                    let set = (card.set || 'ERB').trim();
                                    if (!set || set === '') {
                                        set = 'ERB';
                                    }
                                    
                                    if (!name) {
                                        return;
                                    }
                                    
                                    const key = `${name}|${set}`;
                                    if (!groups.has(key)) {
                                        groups.set(key, []);
                                    }
                                    groups.get(key).push(card);
                                });
                                
                                // Sort each group: original art first, then alternates
                                groups.forEach((group, key) => {
                                    group.sort((a, b) => {
                                        const aImage = a.image_path || a.image || '';
                                        const bImage = b.image_path || b.image || '';
                                        const aIsAlternate = aImage.includes('/alternate/');
                                        const bIsAlternate = bImage.includes('/alternate/');
                                        
                                        if (aIsAlternate && !bIsAlternate) return 1;
                                        if (!aIsAlternate && bIsAlternate) return -1;
                                        return 0;
                                    });
                                });
                                
                                
                                // Store the grouped tile count for use in header rendering
                                characterTileCount = groups.size;
                                
                                // Debug: Log groups with multiple cards
                                const groupsWithMultiple = Array.from(groups.entries()).filter(([key, group]) => group.length > 1);
                                
                                // Track rendered cards to prevent duplicates
                                const renderedKeys = new Set();
                                
                                cardsHtml = '';
                                groups.forEach((group, key) => {
                                    if (group.length === 0) return;
                                    
                                    // Use first card (original art) as representative
                                    const representative = group[0];
                                    const name = (representative.name || '').trim();
                                    const set = (representative.set || 'ERB').trim() || 'ERB';
                                    const renderKey = `${name}|${set}`;
                                    
                                    // Skip if already rendered
                                    if (renderedKeys.has(renderKey)) {
                                        return;
                                    }
                                    
                                    renderedKeys.add(renderKey);
                                    
                                    // Store all alternate arts
                                    const allCards = group.map(card => ({
                                        id: card.id,
                                        imagePath: getCardImagePath(card, category.type),
                                        name: card.name
                                    }));
                                    const allCardsJson = JSON.stringify(allCards).replace(/"/g, '&quot;');
                                    
                                    // Use original art (first card) for display
                                    const displayCard = allCards[0];
                                    
                                    const card = representative; // Use representative for stats
                                    const stats = [
                                        { label: 'TL:', value: card.threat_level || 0, color: '#808080' }, // Gray - Threat Level
                                        { label: 'E:', value: card.energy || 0, color: '#FFD700' },      // Yellow - Energy
                                        { label: 'C:', value: card.combat || 0, color: '#FF8C00' },     // Dark Orange - Combat (redder)
                                        { label: 'BF:', value: card.brute_force || 0, color: '#32CD32' }, // Green - Brute Force
                                        { label: 'I:', value: card.intelligence || 0, color: '#6495ED' } // Lighter Blue - Intelligence
                                    ];
                                    
                                    const statsHtml = stats.map(stat => 
                                        `<span class="character-stat"><span class="stat-label">${stat.label}</span><span class="stat-value" style="color: ${stat.color};">${stat.value}</span></span>`
                                    ).join(' ');
                                    
                                    // Check if ANY alternate art of this character is already in deck
                                    // This includes checking all cards in the group (all alternate arts)
                                    const isCharacterInDeck = window.deckEditorCards.some(deckCard => 
                                        deckCard.type === 'character' && group.some(gc => gc.id === deckCard.cardId)
                                    );
                                    
                                    // Check if this character is One Per Deck and already in deck
                                    const isOnePerDeck = card.one_per_deck === true || card.is_one_per_deck === true;
                                    const isOnePerDeckInDeck = isOnePerDeck && isCharacterInDeck;
                                    
                                    const disabledClass = (isCharacterLimitReached || isCharacterInDeck) ? 'disabled' : '';
                                    let disabledTitle = '';
                                    if (isCharacterLimitReached) {
                                        disabledTitle = 'Character limit reached (max 4)';
                                    } else if (isCharacterInDeck) {
                                        disabledTitle = 'This character is already in your deck';
                                    }
                                    
                                    cardsHtml += `
                                        <div class="card-item character-card ${disabledClass}" 
                                             draggable="${!(isCharacterLimitReached || isCharacterInDeck)}" 
                                             data-type="${category.type}" 
                                             data-id="${displayCard.id}"
                                             data-all-cards="${allCardsJson}"
                                             onmouseenter="showCardHoverModal('${displayCard.imagePath}', '${name.replace(/'/g, "\\'")}')"
                                             onmouseleave="hideCardHoverModal()"
                                             onclick="handleCardClick(event, '${category.type}', '${displayCard.id}', '${name.replace(/'/g, "\\'")}')"
                                             data-name="${name.replace(/'/g, "\\'")}"
                                             title="${disabledTitle}">
                                            <div class="card-item-content">
                                            <div class="character-name">${name}</div>
                                            <div class="character-stats">${statsHtml}</div>
                                            </div>
                                            <div class="card-item-plus" onclick="handlePlusButtonClick(event, '${category.type}', '${displayCard.id}', '${name}', '${allCardsJson}')" title="${category.type === 'character' ? 'Add to deck (max 4 characters)' : 'Add to deck (multiple copies allowed)'}">+</div>
                                        </div>
                                    `;
                                });
                                
                                                    } else if (category.type === 'mission') {
                            // Special handling for missions - group by mission set
                            const missionSetGroups = {};
                            
                            data.data.forEach(card => {
                                const missionSet = card.mission_set || 'Unknown Mission Set';
                                if (!missionSetGroups[missionSet]) {
                                    missionSetGroups[missionSet] = [];
                                }
                                missionSetGroups[missionSet].push(card);
                            });
                            
                            const missionSetNames = Object.keys(missionSetGroups).sort();
                            cardsHtml = '';
                            
                            missionSetNames.forEach(missionSetName => {
                                const cards = missionSetGroups[missionSetName];
                                
                                // Check mission limit
                                const currentMissionCount = window.deckEditorCards
                                    .filter(card => card.type === 'mission')
                                    .reduce((total, card) => total + card.quantity, 0);
                                const isMissionLimitReached = currentMissionCount >= 7;
                                
                                const cardItems = cards.map(card => {
                                    // Check if this mission is One Per Deck and already in deck
                                    const isOnePerDeck = card.one_per_deck === true || card.is_one_per_deck === true;
                                    const isOnePerDeckInDeck = isOnePerDeck && window.deckEditorCards.some(deckCard => 
                                        deckCard.type === 'mission' && deckCard.cardId === card.id
                                    );
                                    
                                    const disabledClass = (isMissionLimitReached || isOnePerDeckInDeck) ? 'disabled' : '';
                                    let disabledTitle = '';
                                    if (isMissionLimitReached) {
                                        disabledTitle = 'Mission limit reached (max 7)';
                                    } else if (isOnePerDeckInDeck) {
                                        disabledTitle = 'One Per Deck - already in deck';
                                    }
                                    
                                    return `
                                        <div class="card-item ${disabledClass}" 
                                             draggable="${!(isMissionLimitReached || isOnePerDeckInDeck)}" 
                                             data-type="${category.type}" 
                                             data-id="${card.id}"
                                             onmouseenter="showCardHoverModal('${getCardImagePath(card, category.type)}', '${(card[category.nameField] || card.name || '').replace(/'/g, "\\'")}')"
                                             onmouseleave="hideCardHoverModal()"
                                             onclick="handleCardClick(event, '${category.type}', '${card.id}', '${(card[category.nameField] || card.name || '').replace(/'/g, "\\'")}')"
                                             data-name="${(card[category.nameField] || card.name || '').replace(/'/g, "\\'")}"
                                             title="${disabledTitle}">
                                            <div class="card-item-content">${card[category.nameField]}</div>
                                            <div class="card-item-plus" onclick="handlePlusButtonClick(event, '${category.type}', '${card.id}', '${card[category.nameField]}')" title="${category.type === 'character' ? 'Add to deck (max 4 characters)' : 'Add to deck (multiple copies allowed)'}">+</div>
                                        </div>
                                    `;
                                }).join('');
                                
                                cardsHtml += `
                                    <div class="mission-set-group">
                                        <div class="mission-set-group-header" onclick="toggleMissionSetGroup(this)">
                                            <span>${missionSetName} (${cards.length})</span>
                                            <div class="mission-set-controls">
                                                <button class="add-all-btn" onclick="event.stopPropagation(); addAllMissionSetCards('${missionSetName}', ${JSON.stringify(cards).replace(/"/g, '&quot;')})">Add All</button>
                                                <span class="collapse-icon">â–¼</span>
                                            </div>
                                        </div>
                                        <div class="mission-set-group-content collapsed">
                                            ${cardItems}
                                        </div>
                                    </div>
                                `;
                            });
                                                    } else if (category.type === 'event') {
                            // Special handling for events - group by mission set
                            const missionSetGroups = {};
                            
                            data.data.forEach(card => {
                                const missionSet = card.mission_set || 'Unknown Mission Set';
                                if (!missionSetGroups[missionSet]) {
                                    missionSetGroups[missionSet] = [];
                                }
                                missionSetGroups[missionSet].push(card);
                            });
                            
                            const missionSetNames = Object.keys(missionSetGroups).sort();
                            cardsHtml = '';
                            
                            missionSetNames.forEach(missionSetName => {
                                const cards = missionSetGroups[missionSetName];
                                const cardItems = cards.map(card => {
                                    // Check if this event is One Per Deck and already in deck
                                    const isOnePerDeck = card.one_per_deck === true || card.is_one_per_deck === true;
                                    const isOnePerDeckInDeck = isOnePerDeck && window.deckEditorCards.some(deckCard => 
                                        deckCard.type === 'event' && deckCard.cardId === card.id
                                    );
                                    
                                    const disabledClass = isOnePerDeckInDeck ? 'disabled' : '';
                                    const disabledTitle = isOnePerDeckInDeck ? 'One Per Deck - already in deck' : '';
                                    
                                    return `
                                        <div class="card-item ${disabledClass}" 
                                             draggable="${!isOnePerDeckInDeck}" 
                                             data-type="${category.type}" 
                                             data-id="${card.id}"
                                             onmouseenter="showCardHoverModal('${getCardImagePath(card, category.type)}', '${(card[category.nameField] || card.name || '').replace(/'/g, "\\'")}')"
                                             onmouseleave="hideCardHoverModal()"
                                             onclick="handleCardClick(event, '${category.type}', '${card.id}', '${(card[category.nameField] || card.name || '').replace(/'/g, "\\'")}')"
                                             data-name="${(card[category.nameField] || card.name || '').replace(/'/g, "\\'")}"
                                             title="${disabledTitle}">
                                            <div class="card-item-content">${card[category.nameField]}</div>
                                            <div class="card-item-plus" onclick="handlePlusButtonClick(event, '${category.type}', '${card.id}', '${card[category.nameField]}')" title="${category.type === 'character' ? 'Add to deck (max 4 characters)' : 'Add to deck (multiple copies allowed)'}">+</div>
                                        </div>
                                    `;
                                }).join('');
                                
                                cardsHtml += `
                                    <div class="mission-set-group">
                                        <div class="mission-set-group-header" onclick="toggleMissionSetGroup(this)">
                                            <span>${missionSetName} (${cards.length})</span>
                                            <span class="collapse-icon">â–¼</span>
                                        </div>
                                        <div class="mission-set-group-content collapsed">
                                            ${cardItems}
                                        </div>
                                    </div>
                                `;
                            });
                                                    } else if (category.type === 'special') {
                            // Special handling for special cards - group by character name, then by card name to consolidate alternate arts
                            
                            // First, group by character name
                            const characterGroups = {};
                            
                            data.data.forEach(card => {
                                const characterName = card.character || 'Any Character';
                                if (!characterGroups[characterName]) {
                                    characterGroups[characterName] = [];
                                }
                                characterGroups[characterName].push(card);
                            });
                            
                            const characterNames = Object.keys(characterGroups).sort();
                            cardsHtml = '';
                            
                            // Track total unique special cards across all character groups
                            let totalUniqueSpecialCards = 0;
                            
                            characterNames.forEach(characterName => {
                                const cardsInCharacterGroup = characterGroups[characterName];
                                
                                // Group cards by name to consolidate alternate arts
                                const cardGroups = new Map();
                                cardsInCharacterGroup.forEach(card => {
                                    const cardName = (card.name || '').trim();
                                    
                                    if (!cardName) {
                                        console.warn('[IndexHTML] Skipping special card with empty name:', card);
                                        return;
                                    }
                                    
                                    const key = cardName;
                                    if (!cardGroups.has(key)) {
                                        cardGroups.set(key, []);
                                    }
                                    cardGroups.get(key).push(card);
                                });
                                
                                // Add to total count
                                totalUniqueSpecialCards += cardGroups.size;
                                
                                // Sort each group: original art first, then alternates
                                cardGroups.forEach((group, key) => {
                                    group.sort((a, b) => {
                                        const aImage = a.image_path || a.image || '';
                                        const bImage = b.image_path || b.image || '';
                                        const aIsAlternate = aImage.includes('/alternate/');
                                        const bIsAlternate = bImage.includes('/alternate/');
                                        
                                        if (aIsAlternate && !bIsAlternate) return 1;
                                        if (!aIsAlternate && bIsAlternate) return -1;
                                        return 0;
                                    });
                                });
                                
                                // Track rendered cards to prevent duplicates
                                const renderedKeys = new Set();
                                
                                const cardItems = [];
                                cardGroups.forEach((group, cardName) => {
                                    if (group.length === 0) return;
                                    
                                    // Use first card (original art) as representative
                                    const representative = group[0];
                                    const name = (representative.name || '').trim();
                                    
                                    // Skip if already rendered
                                    if (renderedKeys.has(name)) {
                                        console.warn(`[IndexHTML] SKIPPING duplicate special card: "${name}"`);
                                        return;
                                    }
                                    
                                    renderedKeys.add(name);
                                    
                                    // Store all alternate arts
                                    const allCards = group.map(card => ({
                                        id: card.id,
                                        imagePath: getCardImagePath(card, category.type),
                                        name: card.name
                                    }));
                                    const allCardsJson = JSON.stringify(allCards).replace(/"/g, '&quot;');
                                    
                                    // Use original art (first card) for display
                                    const displayCard = allCards[0];
                                    
                                    // Check if this special card is One Per Deck and already in deck
                                    // Check if ANY alternate art of this card is already in deck
                                    const isOnePerDeck = representative.one_per_deck === true || representative.is_one_per_deck === true;
                                    const isOnePerDeckInDeck = isOnePerDeck && window.deckEditorCards.some(deckCard => 
                                        deckCard.type === 'special' && group.some(gc => gc.id === deckCard.cardId)
                                    );
                                    
                                    const disabledClass = isOnePerDeckInDeck ? 'disabled' : '';
                                    const disabledTitle = isOnePerDeckInDeck ? 'One Per Deck - already in deck' : '';
                                    
                                    cardItems.push(`
                                        <div class="card-item ${disabledClass}" 
                                             draggable="${!isOnePerDeckInDeck}" 
                                             data-type="${category.type}" 
                                             data-id="${displayCard.id}"
                                             data-all-cards="${allCardsJson}"
                                             onmouseenter="showCardHoverModal('${displayCard.imagePath}', '${name.replace(/'/g, "\\'")}')"
                                             onmouseleave="hideCardHoverModal()"
                                             onclick="handleCardClick(event, '${category.type}', '${displayCard.id}', '${name.replace(/'/g, "\\'")}')"
                                             data-name="${name.replace(/'/g, "\\'")}"
                                             title="${disabledTitle}">
                                            <div class="card-item-content">${name}</div>
                                            <div class="card-item-plus" onclick="handlePlusButtonClick(event, '${category.type}', '${displayCard.id}', '${name}', '${allCardsJson}')" title="Add to deck (multiple copies allowed)">+</div>
                                        </div>
                                    `);
                                });
                                
                                // Sort card items by name
                                cardItems.sort((a, b) => {
                                    const aMatch = a.match(/data-name="([^"]+)"/);
                                    const bMatch = b.match(/data-name="([^"]+)"/);
                                    const aName = aMatch ? aMatch[1] : '';
                                    const bName = bMatch ? bMatch[1] : '';
                                    return aName.localeCompare(bName);
                                });
                                
                                // Escape single quotes and HTML-encode characterName for use in onclick handler
                                const escapedCharacterName = characterName.replace(/'/g, "\\'").replace(/"/g, '&quot;');
                                // Also escape for HTML display
                                const htmlEscapedCharacterName = characterName.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#39;');
                                
                                cardsHtml += `
                                    <div class="character-group">
                                        <div class="character-group-header" onclick="toggleCharacterGroup(this)">
                                            <span>${htmlEscapedCharacterName} (${cardGroups.size})</span>
                                            <button class="add-all-special-btn" onclick="event.stopPropagation(); addAllSpecialCardsForCharacter('${escapedCharacterName}')">Add All</button>
                                            <span class="collapse-icon">â–¶</span>
                                        </div>
                                        <div class="character-group-content collapsed">
                                            ${cardItems.join('')}
                                        </div>
                                    </div>
                                `;
                            });
                            
                            // Store the grouped tile count for use in header rendering
                            specialCardTileCount = totalUniqueSpecialCards;
                            
                        } else if (category.type === 'advanced-universe') {
                            // Special handling for advanced universe cards - group by character name
                            const characterGroups = {};
                            
                            data.data.forEach(card => {
                                const characterName = card.character || 'Any Character';
                                if (!characterGroups[characterName]) {
                                    characterGroups[characterName] = [];
                                }
                                characterGroups[characterName].push(card);
                            });
                            
                            const characterNames = Object.keys(characterGroups).sort();
                            cardsHtml = '';
                            
                            characterNames.forEach(characterName => {
                                const cards = characterGroups[characterName];
                                const cardItems = cards.map(card => {
                                    // Check if this advanced-universe card is One Per Deck and already in deck
                                    const isOnePerDeck = card.one_per_deck === true || card.is_one_per_deck === true;
                                    const isOnePerDeckInDeck = isOnePerDeck && window.deckEditorCards.some(deckCard => 
                                        deckCard.type === 'advanced-universe' && deckCard.cardId === card.id
                                    );
                                    
                                    const disabledClass = isOnePerDeckInDeck ? 'disabled' : '';
                                    const disabledTitle = isOnePerDeckInDeck ? 'One Per Deck - already in deck' : '';
                                    
                                    return `
                                        <div class="card-item ${disabledClass}" 
                                             draggable="${!isOnePerDeckInDeck}" 
                                             data-type="${category.type}" 
                                             data-id="${card.id}"
                                             onmouseenter="showCardHoverModal('${getCardImagePath(card, category.type)}', '${(card[category.nameField] || card.name || '').replace(/'/g, "\\'")}')"
                                             onmouseleave="hideCardHoverModal()"
                                             onclick="handleCardClick(event, '${category.type}', '${card.id}', '${(card[category.nameField] || card.name || '').replace(/'/g, "\\'")}')"
                                             data-name="${(card[category.nameField] || card.name || '').replace(/'/g, "\\'")}"
                                             title="${disabledTitle}">
                                            <div class="card-item-content">${card[category.nameField]}</div>
                                            <div class="card-item-plus" onclick="handlePlusButtonClick(event, '${category.type}', '${card.id}', '${card[category.nameField]}')" title="${category.type === 'character' ? 'Add to deck (max 4 characters)' : 'Add to deck (multiple copies allowed)'}">+</div>
                                        </div>
                                    `;
                                }).join('');
                                
                                cardsHtml += `
                                    <div class="character-group">
                                        <div class="character-group-header" onclick="toggleCharacterGroup(this)">
                                            <span>${characterName} (${cards.length})</span>
                                            <button class="add-all-special-btn" onclick="event.stopPropagation(); addAllAdvancedUniverseCardsForCharacter('${characterName}')">Add All</button>
                                            <span class="collapse-icon">â–¶</span>
                                        </div>
                                        <div class="character-group-content collapsed">
                                            ${cardItems}
                                        </div>
                                    </div>
                                `;
                            });
                        } else if (category.type === 'teamwork') {
                            // Special handling for teamwork cards - group by "To Use" type
                            const typeGroups = {};
                            
                            data.data.forEach(card => {
                                // Extract just the type part (e.g., "6 Energy" -> "Energy", "7 Combat" -> "Combat")
                                const typeMatch = card.to_use.match(/\d+\s+(.+)/);
                                const toUseType = typeMatch ? typeMatch[1] : 'Unknown';
                                
                                if (!typeGroups[toUseType]) {
                                    typeGroups[toUseType] = [];
                                }
                                typeGroups[toUseType].push(card);
                            });
                            
                            // Define the preferred order for teamwork types
                            const preferredOrder = ['Energy', 'Combat', 'Brute Force', 'Intelligence', 'Any-Power'];
                            const typeNames = Object.keys(typeGroups).sort((a, b) => {
                                const aIndex = preferredOrder.indexOf(a);
                                const bIndex = preferredOrder.indexOf(b);
                                // If both are in preferred order, sort by their position
                                if (aIndex !== -1 && bIndex !== -1) {
                                    return aIndex - bIndex;
                                }
                                // If only one is in preferred order, prioritize it
                                if (aIndex !== -1) return -1;
                                if (bIndex !== -1) return 1;
                                // If neither is in preferred order, sort alphabetically
                                return a.localeCompare(b);
                            });
                            cardsHtml = '';
                            
                            typeNames.forEach(typeName => {
                                const cards = typeGroups[typeName];
                                const cardItems = cards.map(card => {
                                    const summary = `${card.to_use} To Use -> ${card.followup_attack_types} (${card.first_attack_bonus}/${card.second_attack_bonus})`;
                                    
                                    // Check if this teamwork card is One Per Deck and already in deck
                                    const isOnePerDeck = card.one_per_deck === true || card.is_one_per_deck === true;
                                    const isOnePerDeckInDeck = isOnePerDeck && window.deckEditorCards.some(deckCard => 
                                        deckCard.type === 'teamwork' && deckCard.cardId === card.id
                                    );
                                    
                                    const disabledClass = isOnePerDeckInDeck ? 'disabled' : '';
                                    const disabledTitle = isOnePerDeckInDeck ? 'One Per Deck - already in deck' : '';
                                    
                                    return `
                                        <div class="card-item ${disabledClass}" 
                                             draggable="${!isOnePerDeckInDeck}" 
                                             data-type="${category.type}" 
                                             data-id="${card.id}"
                                             onmouseenter="showCardHoverModal('${getCardImagePath(card, category.type)}', '${summary}')"
                                             onmouseleave="hideCardHoverModal()"
                                             onclick="handleCardClick(event, '${category.type}', '${card.id}', '${summary}')"
                                             data-name="${summary}"
                                             title="${disabledTitle}">
                                            <div class="card-item-content">${summary}</div>
                                            <div class="card-item-plus" onclick="handlePlusButtonClick(event, '${category.type}', '${card.id}', '${summary}')" title="${category.type === 'character' ? 'Add to deck (max 4 characters)' : 'Add to deck (multiple copies allowed)'}">+</div>
                                        </div>
                                    `;
                                }).join('');
                                
                                cardsHtml += `
                                    <div class="character-group">
                                        <div class="character-group-header" onclick="toggleCharacterGroup(this)">
                                            <span>${typeName} (${cards.length})</span>
                                            <span class="collapse-icon">â–¶</span>
                                        </div>
                                        <div class="character-group-content collapsed">
                                            ${cardItems}
                                        </div>
                                    </div>
                                `;
                            });
                        } else if (category.type === 'ally-universe') {
                            // Special handling for ally cards - show summary with stat requirements and attack info
                            cardsHtml = data.data.map(card => {
                                const summary = `${card.card_name} - ${card.stat_to_use} ${card.stat_type_to_use} â†’ ${card.attack_value} ${card.attack_type}`;
                                
                                // Check if this ally-universe card is One Per Deck and already in deck
                                const isOnePerDeck = card.one_per_deck === true || card.is_one_per_deck === true;
                                const isOnePerDeckInDeck = isOnePerDeck && window.deckEditorCards.some(deckCard => 
                                    deckCard.type === 'ally-universe' && deckCard.cardId === card.id
                                );
                                
                                const disabledClass = isOnePerDeckInDeck ? 'disabled' : '';
                                const disabledTitle = isOnePerDeckInDeck ? 'One Per Deck - already in deck' : '';
                                
                                return `
                                    <div class="card-item ${disabledClass}" 
                                         draggable="${!isOnePerDeckInDeck}" 
                                         data-type="${category.type}" 
                                         data-id="${card.id}"
                                         onmouseenter="showCardHoverModal('${getCardImagePath(card, category.type)}', '${summary}')"
                                         onmouseleave="hideCardHoverModal()"
                                         onclick="handleCardClick(event, '${category.type}', '${card.id}', '${summary}')"
                                         data-name="${summary}"
                                         title="${disabledTitle}">
                                        <div class="card-item-content">${summary}</div>
                                        <div class="card-item-plus" onclick="handlePlusButtonClick(event, '${category.type}', '${card.id}', '${summary}')" title="${category.type === 'character' ? 'Add to deck (max 4 characters)' : 'Add to deck (multiple copies allowed)'}">+</div>
                                    </div>
                                `;
                            }).join('');
                        } else if (category.type === 'training') {
                            // Special handling for training cards - show summary with types and bonus
                            cardsHtml = data.data.map(card => {
                                const summary = `${card.card_name.replace(/^Training \(/, '').replace(/\)$/, '')} - ${card.type_1} + ${card.type_2} (${card.value_to_use} â†’ ${card.bonus})`;
                                
                                // Check if this training card is One Per Deck and already in deck
                                const isOnePerDeck = card.one_per_deck === true || card.is_one_per_deck === true;
                                const isOnePerDeckInDeck = isOnePerDeck && window.deckEditorCards.some(deckCard => 
                                    deckCard.type === 'training' && deckCard.cardId === card.id
                                );
                                
                                const disabledClass = isOnePerDeckInDeck ? 'disabled' : '';
                                const disabledTitle = isOnePerDeckInDeck ? 'One Per Deck - already in deck' : '';
                                
                                return `
                                    <div class="card-item ${disabledClass}" 
                                         draggable="${!isOnePerDeckInDeck}" 
                                         data-type="${category.type}" 
                                         data-id="${card.id}"
                                         onmouseenter="showCardHoverModal('${getCardImagePath(card, category.type)}', '${summary}')"
                                         onmouseleave="hideCardHoverModal()"
                                         onclick="handleCardClick(event, '${category.type}', '${card.id}', '${summary}')"
                                         data-name="${summary}"
                                         title="${disabledTitle}">
                                        <div class="card-item-content">${summary}</div>
                                        <div class="card-item-plus" onclick="handlePlusButtonClick(event, '${category.type}', '${card.id}', '${summary}')" title="${category.type === 'character' ? 'Add to deck (max 4 characters)' : 'Add to deck (multiple copies allowed)'}">+</div>
                                    </div>
                                `;
                            }).join('');
                        } else if (category.type === 'basic-universe') {
                            // Special handling for basic universe cards - show summary with type, value, and bonus
                            cardsHtml = data.data.map(card => {
                                const summary = `${card.card_name} - ${card.type} (${card.value_to_use} â†’ ${card.bonus})`;
                                const escapedSummary = summary.replace(/'/g, "\\'").replace(/"/g, '\\"');
                                const escapedImagePath = getCardImagePath(card, category.type).replace(/'/g, "\\'").replace(/"/g, '\\"');
                                
                                // Check if this basic-universe card is One Per Deck and already in deck
                                const isOnePerDeck = card.one_per_deck === true || card.is_one_per_deck === true;
                                const isOnePerDeckInDeck = isOnePerDeck && window.deckEditorCards.some(deckCard => 
                                    deckCard.type === 'basic-universe' && deckCard.cardId === card.id
                                );
                                
                                const disabledClass = isOnePerDeckInDeck ? 'disabled' : '';
                                const disabledTitle = isOnePerDeckInDeck ? 'One Per Deck - already in deck' : '';
                                
                                return `
                                    <div class="card-item ${disabledClass}" 
                                         draggable="${!isOnePerDeckInDeck}" 
                                         data-type="${category.type}" 
                                         data-id="${card.id}"
                                         onmouseenter="showCardHoverModal('${escapedImagePath}', '${escapedSummary}')"
                                         onmouseleave="hideCardHoverModal()"
                                         onclick="handleCardClick(event, '${category.type}', '${card.id}', '${escapedSummary}')"
                                         data-name="${summary}"
                                         title="${disabledTitle}">
                                        <div class="card-item-content">${summary}</div>
                                        <div class="card-item-plus" onclick="handlePlusButtonClick(event, '${category.type}', '${card.id}', '${escapedSummary}')" title="${category.type === 'character' ? 'Add to deck (max 4 characters)' : 'Add to deck (multiple copies allowed)'}">+</div>
                                    </div>
                                `;
                            }).join('');
                        } else if (category.type === 'power') {
                            // Special handling for power cards - group by power type, then by value and universe to consolidate alternate arts
                            
                            // First, group by power type
                            const typeGroups = {};
                            
                            data.data.forEach(card => {
                                const powerType = card.power_type;
                                if (!typeGroups[powerType]) {
                                    typeGroups[powerType] = [];
                                }
                                typeGroups[powerType].push(card);
                            });
                            
                            // Define the preferred order for power types (OverPower official order)
                            // Using normalized names (with hyphens) to match the normalization logic
                            const preferredOrder = ['Energy', 'Combat', 'Brute-Force', 'Intelligence', 'Multi-Power', 'Any-Power'];
                            const typeNames = Object.keys(typeGroups).sort((a, b) => {
                                // Normalize power type names for comparison
                                const normalizeType = (type) => type.replace(/\s+/g, '-');
                                const normalizedA = normalizeType(a);
                                const normalizedB = normalizeType(b);
                                
                                const aIndex = preferredOrder.indexOf(normalizedA);
                                const bIndex = preferredOrder.indexOf(normalizedB);
                                
                                // If both are in preferred order, sort by their position
                                if (aIndex !== -1 && bIndex !== -1) {
                                    return aIndex - bIndex;
                                }
                                // If only one is in preferred order, prioritize it
                                if (aIndex !== -1) return -1;
                                if (bIndex !== -1) return 1;
                                // If neither is in preferred order, sort alphabetically
                                return a.localeCompare(b);
                            });
                            cardsHtml = '';
                            
                            // Track total unique power cards across all type groups
                            let totalUniquePowerCards = 0;
                            
                            typeNames.forEach(typeName => {
                                const cardsInTypeGroup = typeGroups[typeName];
                                
                                // Group cards by value only (not by set) to consolidate alternate arts across all sets
                                const cardGroups = new Map();
                                cardsInTypeGroup.forEach(card => {
                                    const value = String(card.value || '').trim();
                                    
                                    // Group by value only, so cards from different sets are together
                                    const key = value;
                                    if (!cardGroups.has(key)) {
                                        cardGroups.set(key, []);
                                    }
                                    cardGroups.get(key).push(card);
                                });
                                
                                // Add to total count
                                totalUniquePowerCards += cardGroups.size;
                                
                                // Sort each group: ERB set first, then other sets; original art first, then alternates
                                cardGroups.forEach((group, key) => {
                                    group.sort((a, b) => {
                                        // First, prioritize ERB set
                                        const aSet = (a.set || 'ERB').trim();
                                        const bSet = (b.set || 'ERB').trim();
                                        const aIsERB = aSet === 'ERB';
                                        const bIsERB = bSet === 'ERB';
                                        
                                        if (aIsERB && !bIsERB) return -1; // ERB first
                                        if (!aIsERB && bIsERB) return 1;  // ERB first
                                        
                                        // If same set priority, then sort by original vs alternate art
                                        const aImage = a.image_path || a.image || '';
                                        const bImage = b.image_path || b.image || '';
                                        const aIsAlternate = aImage.includes('/alternate/');
                                        const bIsAlternate = bImage.includes('/alternate/');
                                        
                                        if (aIsAlternate && !bIsAlternate) return 1;
                                        if (!aIsAlternate && bIsAlternate) return -1;
                                        return 0;
                                    });
                                });
                                
                                // Sort groups by value (key is now just the value, not value|set)
                                const sortedCardGroups = Array.from(cardGroups.entries()).sort((a, b) => {
                                    const valueA = parseInt(a[0]) || 0;
                                    const valueB = parseInt(b[0]) || 0;
                                    return valueA - valueB;
                                });
                                
                                // Track rendered cards to prevent duplicates
                                const renderedKeys = new Set();
                                
                                const cardItems = [];
                                sortedCardGroups.forEach(([key, group]) => {
                                    if (group.length === 0) return;
                                    
                                    // Use first card (original art) as representative
                                    const representative = group[0];
                                    const value = String(representative.value || '').trim();
                                    const summary = `${value} - ${typeName}`;
                                    const renderKey = `${value}|${typeName}`;
                                    
                                    // Skip if already rendered
                                    if (renderedKeys.has(renderKey)) {
                                        console.warn(`[IndexHTML] SKIPPING duplicate power card: "${summary}"`);
                                        return;
                                    }
                                    
                                    renderedKeys.add(renderKey);
                                    
                                    // Store all alternate arts
                                    const allCards = group.map(card => ({
                                        id: card.id,
                                        imagePath: getCardImagePath(card, category.type),
                                        name: `${card.value} - ${card.power_type}`
                                    }));
                                    const allCardsJson = JSON.stringify(allCards).replace(/"/g, '&quot;');
                                    
                                    // Use original art (first card) for display
                                    const displayCard = allCards[0];
                                    
                                    // Check if this power card is One Per Deck and already in deck
                                    // Check if ANY alternate art of this card is already in deck
                                    const isOnePerDeck = representative.one_per_deck === true || representative.is_one_per_deck === true;
                                    const isOnePerDeckInDeck = isOnePerDeck && window.deckEditorCards.some(deckCard => 
                                        deckCard.type === 'power' && group.some(gc => gc.id === deckCard.cardId)
                                    );
                                    
                                    const disabledClass = isOnePerDeckInDeck ? 'disabled' : '';
                                    const disabledTitle = isOnePerDeckInDeck ? 'One Per Deck - already in deck' : '';
                                    
                                    cardItems.push(`
                                        <div class="card-item ${disabledClass}" 
                                             draggable="${!isOnePerDeckInDeck}" 
                                             data-type="${category.type}" 
                                             data-id="${displayCard.id}"
                                             data-all-cards="${allCardsJson}"
                                             onmouseenter="showCardHoverModal('${displayCard.imagePath}', '${summary.replace(/'/g, "\\'")}')"
                                             onmouseleave="hideCardHoverModal()"
                                             onclick="handleCardClick(event, '${category.type}', '${displayCard.id}', '${summary.replace(/'/g, "\\'")}')"
                                             data-name="${summary.replace(/'/g, "\\'")}"
                                             title="${disabledTitle}">
                                            <div class="card-item-content">${summary}</div>
                                            <div class="card-item-plus" onclick="handlePlusButtonClick(event, '${category.type}', '${displayCard.id}', '${summary}', '${allCardsJson}')" title="Add to deck (multiple copies allowed)">+</div>
                                        </div>
                                    `);
                                });
                                
                                // Add "Add All" button for Multi-Power and Any-Power subsections
                                const normalizedTypeName = typeName.replace(/\s+/g, '-');
                                const addAllButton = (normalizedTypeName === 'Multi-Power' || normalizedTypeName === 'Any-Power') ? 
                                    `<button class="add-all-btn" onclick="event.stopPropagation(); addAllPowerCards('${typeName}', ${JSON.stringify(cardsInTypeGroup).replace(/"/g, '&quot;')})">Add All</button>` : '';
                                
                                cardsHtml += `
                                    <div class="character-group">
                                        <div class="character-group-header" onclick="toggleCharacterGroup(this)">
                                            <span>${typeName} (${cardGroups.size})</span>
                                            <div class="mission-set-controls">
                                                ${addAllButton}
                                                <span class="collapse-icon">â–¶</span>
                                            </div>
                                        </div>
                                        <div class="character-group-content collapsed">
                                            ${cardItems.join('')}
                                        </div>
                                    </div>
                                `;
                            });
                            
                            // Store the grouped tile count for use in header rendering
                            powerCardTileCount = totalUniquePowerCards;
                            
                        } else if (category.type === 'location') {
                            // Group locations by name (same as characters) - single entry per location, art modal for alternates
                            const groups = new Map();
                            data.data.forEach(card => {
                                const name = (card.name || '').trim();
                                if (!name) return;
                                const key = name;
                                if (!groups.has(key)) {
                                    groups.set(key, []);
                                }
                                groups.get(key).push(card);
                            });
                            
                            // Sort each group: original art first, then alternates
                            groups.forEach((group) => {
                                group.sort((a, b) => {
                                    const aImage = a.image_path || a.image || '';
                                    const bImage = b.image_path || b.image || '';
                                    const aIsAlternate = aImage.includes('/alternate/');
                                    const bIsAlternate = bImage.includes('/alternate/');
                                    if (aIsAlternate && !bIsAlternate) return 1;
                                    if (!aIsAlternate && bIsAlternate) return -1;
                                    return 0;
                                });
                            });
                            
                            locationTileCount = groups.size;
                            
                            const currentLocationCount = window.deckEditorCards
                                .filter(card => card.type === 'location')
                                .reduce((total, card) => total + card.quantity, 0);
                            const isLocationLimitReached = currentLocationCount >= 1;
                            
                            cardsHtml = '';
                            groups.forEach((group) => {
                                if (group.length === 0) return;
                                const representative = group[0];
                                const name = (representative.name || '').trim();
                                
                                const allCards = group.map(card => ({
                                    id: card.id,
                                    imagePath: getCardImagePath(card, category.type),
                                    name: card.name
                                }));
                                const allCardsJson = JSON.stringify(allCards).replace(/"/g, '&quot;');
                                const displayCard = allCards[0];
                                
                                const stats = [
                                    { label: 'TL:', value: representative.threat_level || 0, color: '#808080' }
                                ];
                                const statsHtml = stats.map(stat => 
                                    `<span class="location-stat"><span class="stat-label">${stat.label}</span><span class="stat-value" style="color: ${stat.color};">${stat.value}</span></span>`
                                ).join(' ');
                                
                                // Check if ANY alternate art of this location is already in deck
                                const isLocationInDeck = window.deckEditorCards.some(deckCard => 
                                    deckCard.type === 'location' && group.some(gc => gc.id === deckCard.cardId)
                                );
                                
                                const disabledClass = (isLocationLimitReached || isLocationInDeck) ? 'disabled' : '';
                                let disabledTitle = '';
                                if (isLocationLimitReached) {
                                    disabledTitle = 'Location limit reached (max 1)';
                                } else if (isLocationInDeck) {
                                    disabledTitle = 'One Per Deck - already in deck';
                                }
                                
                                const locationIds = group.map(gc => gc.id).join(',');
                                cardsHtml += `
                                    <div class="card-item location-card ${disabledClass}" 
                                         draggable="${!(isLocationLimitReached || isLocationInDeck)}" 
                                         data-type="${category.type}" 
                                         data-id="${displayCard.id}"
                                         data-location-ids="${locationIds}"
                                         data-all-cards="${allCardsJson}"
                                         onmouseenter="showCardHoverModal('${displayCard.imagePath}', '${name.replace(/'/g, "\\'")}')"
                                         onmouseleave="hideCardHoverModal()"
                                         onclick="handleCardClick(event, '${category.type}', '${displayCard.id}', '${name.replace(/'/g, "\\'")}')"
                                         data-name="${name.replace(/'/g, "\\'")}"
                                         title="${disabledTitle}">
                                        <div class="card-item-content">
                                            <div class="location-name">${name}</div>
                                            <div class="location-stats">${statsHtml}</div>
                                        </div>
                                        <div class="card-item-plus" onclick="handlePlusButtonClick(event, '${category.type}', '${displayCard.id}', '${name}', '${allCardsJson}')" title="Add to deck (max 1 location)">+</div>
                                    </div>
                                `;
                            });
                        } else {
                            // Regular handling for other card types
                            cardsHtml = data.data.map(card => `
                                <div class="card-item" 
                                     draggable="true" 
                                     data-type="${category.type}" 
                                     data-id="${card.id}"
                                     onmouseenter="showCardHoverModal('${getCardImagePath(card, category.type)}', '${(card[category.nameField] || card.name || '').replace(/'/g, "\\'")}')"
                                     onmouseleave="hideCardHoverModal()"
                                     onclick="handleCardClick(event, '${category.type}', '${card.id}', '${(card[category.nameField] || card.name || '').replace(/'/g, "\\'")}')"
                                     data-name="${(card[category.nameField] || card.name || '').replace(/'/g, "\\'")}">
                                    <div class="card-item-content">${card[category.nameField]}</div>
                                    <div class="card-item-plus" onclick="handlePlusButtonClick(event, '${category.type}', '${card.id}', '${card[category.nameField]}')" title="${category.type === 'character' ? 'Add to deck (max 4 characters)' : 'Add to deck (multiple copies allowed)'}">+</div>
                                </div>
                            `).join('');
                        }
                            
                            // Always collapse all available card categories by default
                            const isCollapsed = true;
                            const collapsedClass = isCollapsed ? 'collapsed' : '';
                            const collapseIcon = isCollapsed ? 'â–¶' : 'â–¼';
                            
                            if (category.type === 'special') {
                                // Special handling for special cards header with toggle
                                // Use grouped tile count instead of raw data length
                                const displayCount = specialCardTileCount !== null ? specialCardTileCount : data.data.length;
                                categoriesHtml += `
                                    <div class="card-category">
                                        <div class="card-category-header ${collapsedClass}" onclick="toggleCategory(this)">
                                            <div class="category-header-content">
                                                <span>${category.name} (${displayCount})</span>
                                                <label class="filter-toggle" onclick="event.stopPropagation()">
                                                    <input type="checkbox" id="specialCardsCharacterFilter" onchange="toggleSpecialCardsCharacterFilter()">
                                                    <span class="toggle-label">Hide Unusables</span>
                                                </label>
                                            </div>
                                            <div class="category-header-controls">
                                                <span class="collapse-icon">${collapseIcon}</span>
                                            </div>
                                        </div>
                                        <div class="card-category-content ${collapsedClass}">
                                            ${cardsHtml}
                                        </div>
                                    </div>
                                `;
                            } else if (category.type === 'advanced-universe') {
                                // Special handling for advanced universe cards header with character filter toggle
                                categoriesHtml += `
                                    <div class="card-category">
                                        <div class="card-category-header ${collapsedClass}" onclick="toggleCategory(this)">
                                            <div class="category-header-content">
                                                <span>${category.name} (${data.data.length})</span>
                                                <label class="filter-toggle" onclick="event.stopPropagation()">
                                                    <input type="checkbox" id="advancedUniverseCharacterFilter" onchange="toggleAdvancedUniverseCharacterFilter()">
                                                    <span class="toggle-label">Hide Unusables</span>
                                                </label>
                                            </div>
                                            <div class="category-header-controls">
                                                <span class="collapse-icon">${collapseIcon}</span>
                                            </div>
                                        </div>
                                        <div class="card-category-content ${collapsedClass}">
                                            ${cardsHtml}
                                        </div>
                                    </div>
                                `;
                            } else if (category.type === 'power') {
                                // Special handling for power cards header with character filter toggle
                                // Use grouped tile count instead of raw data length
                                const displayCount = powerCardTileCount !== null ? powerCardTileCount : data.data.length;
                                categoriesHtml += `
                                    <div class="card-category" data-type="power">
                                        <div class="card-category-header ${collapsedClass}" onclick="toggleCategory(this)">
                                            <div class="category-header-content">
                                                <span>${category.name} (${displayCount})</span>
                                                <label class="filter-toggle" onclick="event.stopPropagation()">
                                                    <input type="checkbox" id="powerCardsCharacterFilter" onchange="togglePowerCardsCharacterFilter()">
                                                    <span class="toggle-label">Hide Unusables</span>
                                                </label>
                                            </div>
                                            <div class="category-header-controls">
                                                <span class="collapse-icon">${collapseIcon}</span>
                                            </div>
                                        </div>
                                        <div class="card-category-content ${collapsedClass}">
                                            ${cardsHtml}
                                        </div>
                                    </div>
                                `;
                            } else if (category.type === 'teamwork') {
                                // Teamwork category - with filter toggle
                                categoriesHtml += `
                                    <div class="card-category">
                                        <div class="card-category-header ${collapsedClass}" onclick="toggleCategory(this)">
                                            <div class="category-header-content">
                                                <span>${category.name} (${data.data.length})</span>
                                                <label class="filter-toggle" onclick="event.stopPropagation()">
                                                    <input type="checkbox" id="teamworkCharacterFilter" onchange="toggleTeamworkCharacterFilter()">
                                                    <span class="toggle-label">Hide Unusables</span>
                                                </label>
                                            </div>
                                            <div class="category-header-controls">
                                                <span class="collapse-icon">${collapseIcon}</span>
                                            </div>
                                        </div>
                                        <div class="card-category-content ${collapsedClass}">
                                            ${cardsHtml}
                                        </div>
                                    </div>
                                `;
                            } else if (category.type === 'basic-universe') {
                                // Basic universe category - with filter toggle
                                categoriesHtml += `
                                    <div class="card-category">
                                        <div class="card-category-header ${collapsedClass}" onclick="toggleCategory(this)">
                                            <div class="category-header-content">
                                                <span>${category.name} (${data.data.length})</span>
                                                <label class="filter-toggle" onclick="event.stopPropagation()">
                                                    <input type="checkbox" id="basicUniverseCharacterFilter" onchange="toggleBasicUniverseCharacterFilter()">
                                                    <span class="toggle-label">Hide Unusables</span>
                                                </label>
                                            </div>
                                            <div class="category-header-controls">
                                                <span class="collapse-icon">${collapseIcon}</span>
                                            </div>
                                        </div>
                                        <div class="card-category-content ${collapsedClass}">
                                            ${cardsHtml}
                                        </div>
                                    </div>
                                `;
                            } else if (category.type === 'training') {
                                // Training category - with filter toggle
                                categoriesHtml += `
                                    <div class="card-category">
                                        <div class="card-category-header ${collapsedClass}" onclick="toggleCategory(this)">
                                            <div class="category-header-content">
                                                <span>${category.name} (${data.data.length})</span>
                                                <label class="filter-toggle" onclick="event.stopPropagation()">
                                                    <input type="checkbox" id="trainingCharacterFilter" onchange="toggleTrainingCharacterFilter()">
                                                    <span class="toggle-label">Hide Unusables</span>
                                                </label>
                                            </div>
                                            <div class="category-header-controls">
                                                <span class="collapse-icon">${collapseIcon}</span>
                                            </div>
                                        </div>
                                        <div class="card-category-content ${collapsedClass}">
                                            ${cardsHtml}
                                        </div>
                                    </div>
                                `;
                            } else if (category.type === 'ally-universe') {
                                // Ally universe category - with filter toggle
                                categoriesHtml += `
                                    <div class="card-category">
                                        <div class="card-category-header ${collapsedClass}" onclick="toggleCategory(this)">
                                            <div class="category-header-content">
                                                <span>${category.name} (${data.data.length})</span>
                                                <label class="filter-toggle" onclick="event.stopPropagation()">
                                                    <input type="checkbox" id="allyUniverseCharacterFilter" onchange="toggleAllyUniverseCharacterFilter()">
                                                    <span class="toggle-label">Hide Unusables</span>
                                                </label>
                                            </div>
                                            <div class="category-header-controls">
                                                <span class="collapse-icon">${collapseIcon}</span>
                                            </div>
                                        </div>
                                        <div class="card-category-content ${collapsedClass}">
                                            ${cardsHtml}
                                        </div>
                                    </div>
                                `;
                            } else if (category.type === 'character') {
                                // Special handling for characters with name search
                                // Use grouped tile count instead of raw data length
                                const displayCount = characterTileCount !== null ? characterTileCount : data.data.length;
                                categoriesHtml += `
                                    <div class="card-category">
                                        <div class="card-category-header ${collapsedClass}" onclick="toggleCategory(this)">
                                            <div class="category-header-content">
                                                <span>${category.name} (${displayCount})</span>
                                                <input type="text" class="character-name-search" placeholder="Search names..." 
                                                       onkeyup="filterCharactersByName(this.value)" 
                                                       onclick="expandCharacterCategoryIfNeeded(this); event.stopPropagation()"
                                                       onmousedown="preventCategoryCollapse(event)"
                                                       onselect="preventCategoryCollapse(event)"
                                                       onfocus="preventCategoryCollapse(event)"
                                                       onblur="preventCategoryCollapse(event)">
                                            </div>
                                            <div class="category-header-controls">
                                                <span class="collapse-icon">${collapseIcon}</span>
                                            </div>
                                        </div>
                                        <div class="card-category-content ${collapsedClass}" 
                                             ondragover="handleAvailableCardDragOver(event)" 
                                             ondragleave="handleAvailableCardDragLeave(event)"
                                             ondrop="handleAvailableCardDrop(event)">
                                            ${cardsHtml}
                                        </div>
                                    </div>
                                `;
                            } else if (category.type === 'event') {
                                // Events category - with mission filter toggle
                                categoriesHtml += `
                                    <div class="card-category">
                                        <div class="card-category-header ${collapsedClass}" onclick="toggleCategory(this)">
                                            <div class="category-header-content">
                                                <span>${category.name} (${data.data.length})</span>
                                                <label class="filter-toggle" onclick="event.stopPropagation()">
                                                    <input type="checkbox" id="eventsMissionFilter" onchange="toggleEventsMissionFilter()">
                                                    <span class="toggle-label">Hide Unusables</span>
                                                </label>
                                            </div>
                                            <div class="category-header-controls">
                                                <span class="collapse-icon">${collapseIcon}</span>
                                            </div>
                                        </div>
                                        <div class="card-category-content ${collapsedClass}" 
                                             ondragover="handleAvailableCardDragOver(event)" 
                                             ondragleave="handleAvailableCardDragLeave(event)"
                                             ondrop="handleAvailableCardDrop(event)">
                                            ${cardsHtml}
                                        </div>
                                    </div>
                                `;
                            } else if (category.type === 'location') {
                                // Locations - use grouped tile count (one per location name, alternates open art modal)
                                const displayCount = locationTileCount !== null ? locationTileCount : data.data.length;
                                categoriesHtml += `
                                    <div class="card-category">
                                        <div class="card-category-header ${collapsedClass}" onclick="toggleCategory(this)">
                                            <div class="category-header-content">
                                                <span>${category.name} (${displayCount})</span>
                                            </div>
                                            <div class="category-header-controls">
                                                <span class="collapse-icon">${collapseIcon}</span>
                                            </div>
                                        </div>
                                        <div class="card-category-content ${collapsedClass}" 
                                             ondragover="handleAvailableCardDragOver(event)" 
                                             ondragleave="handleAvailableCardDragLeave(event)"
                                             ondrop="handleAvailableCardDrop(event)">
                                            ${cardsHtml}
                                        </div>
                                    </div>
                                `;
                            } else {
                                // Regular handling for other card types
                                categoriesHtml += `
                                    <div class="card-category">
                                        <div class="card-category-header ${collapsedClass}" onclick="toggleCategory(this)">
                                            <div class="category-header-content">
                                                <span>${category.name} (${data.data.length})</span>
                                            </div>
                                            <div class="category-header-controls">
                                                <span class="collapse-icon">${collapseIcon}</span>
                                            </div>
                                        </div>
                                        <div class="card-category-content ${collapsedClass}" 
                                             ondragover="handleAvailableCardDragOver(event)" 
                                             ondragleave="handleAvailableCardDragLeave(event)"
                                             ondrop="handleAvailableCardDrop(event)">
                                            ${cardsHtml}
                                        </div>
                                    </div>
                                `;
                            }
                }
                }                
                cardCategories.innerHTML = categoriesHtml;
                
                // Update power cards filter to show correct counts after categories are loaded
                updatePowerCardsFilter();
                
                // Update Assist and Ambush dimming status after cards are loaded
                updateAssistLimitStatus();
                updateAmbushLimitStatus();
                
                // Also update counts immediately for initial display
                setTimeout(() => {
                    updatePowerCardsFilter();
                    // Ensure dimming is applied after DOM is fully rendered
                    updateAssistLimitStatus();
                    updateAmbushLimitStatus();
                }, 100);
            } catch (error) {
                console.error('Error loading available cards:', error);
                cardCategories.innerHTML = '<div class="error">Error loading available cards</div>';
            }
        }

        // Expand character category if it's collapsed when search input is clicked
        function expandCharacterCategoryIfNeeded(searchInput) {
            const category = searchInput.closest('.card-category');
            const header = category.querySelector('.card-category-header');
            
            if (header.classList.contains('collapsed')) {
                toggleCategory(header);
            }
        }

        // Prevent search input from collapsing the category when text is selected
        function preventCategoryCollapse(event) {
            event.stopPropagation();
        }

        // Filter characters by name in the Available Cards section
        function filterCharactersByName(searchTerm) {
            // Find the character category specifically
            const characterCategory = document.querySelector('.card-category');
            if (!characterCategory) return;
            
            const characterCards = characterCategory.querySelectorAll('.character-card');
            const searchLower = searchTerm.toLowerCase();
            
            characterCards.forEach(card => {
                const characterName = card.querySelector('.character-name');
                if (characterName) {
                    const name = characterName.textContent.toLowerCase();
                    if (searchLower === '' || name.includes(searchLower)) {
                        card.style.display = 'block';
                    } else {
                        card.style.display = 'none';
                    }
                }
            });
        }
        // setupDragAndDrop function moved to external file

        // handlePlusButtonClick, handleCardClick functions moved to external file

        // Enhanced drag and drop functionality for deck cards - variables moved to external file

        // handleDeckCardDragStart function moved to external file

        // handleDeckCardDragEnd, handleDeckCardDragOver, handleDeckCardDrop, handleAvailableCardDragOver, handleAvailableCardDragLeave, handleAvailableCardDrop, updateDragLayout, reorderDeckCards functions moved to external file


        /**
         * Show alternate art selection modal
         * Make it globally accessible
         */


        // Reserve Character Functions
        function getReserveCharacterButton(cardId, index) {
            // Use window.currentDeckData if available, otherwise fall back to currentDeckData (local scope)
            const deckData = window.currentDeckData || currentDeckData;
            const reserveCharacterId = deckData && deckData.metadata && deckData.metadata.reserve_character;
            const hasReserveCharacter = !!reserveCharacterId;
            const isReadOnlyUI = !!(document.body && document.body.classList && document.body.classList.contains('read-only-mode'));
            
            // Helper function to extract UUID from cardId (removes prefixes like "character_")
            const extractUUID = (id) => {
                if (!id) return null;
                const uuidPattern = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
                if (uuidPattern.test(id)) return id;
                const prefixedMatch = id.match(/^[a-z]+_([0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12})$/i);
                if (prefixedMatch && prefixedMatch[1]) return prefixedMatch[1];
                const parts = id.split('_');
                for (let i = 1; i < parts.length; i++) {
                    const candidate = parts.slice(i).join('_');
                    if (uuidPattern.test(candidate)) return candidate;
                }
                return id;
            };
            
            // Check if this card matches the reserve character
            // Need to check: base cardId, selectedAlternateCardId, and selectedAlternateCardIds array
            let isReserveCharacter = false;
            if (reserveCharacterId && window.deckEditorCards && window.deckEditorCards[index]) {
                const card = window.deckEditorCards[index];
                
                const normalizedReserveId = extractUUID(reserveCharacterId);
                const normalizedCardId = extractUUID(card.cardId);
                
                // Check if reserve_character matches base cardId
                if (normalizedReserveId === normalizedCardId) {
                    isReserveCharacter = true;
                }
                // Check if reserve_character matches selectedAlternateCardId
                else if (card.selectedAlternateCardId) {
                    const normalizedAlternateId = extractUUID(card.selectedAlternateCardId);
                    if (normalizedReserveId === normalizedAlternateId) {
                        isReserveCharacter = true;
                    }
                }
                // Check if reserve_character matches any ID in selectedAlternateCardIds array
                else if (card.selectedAlternateCardIds && Array.isArray(card.selectedAlternateCardIds)) {
                    for (const altId of card.selectedAlternateCardIds) {
                        const normalizedAltId = extractUUID(altId);
                        if (normalizedReserveId === normalizedAltId) {
                            isReserveCharacter = true;
                            break;
                        }
                    }
                }
            } else {
                // Fallback: simple comparison if card data not available
                isReserveCharacter = reserveCharacterId === cardId;
            }

            // Read-only mode behavior:
            // - If a reserve character is set, show ONLY the selected reserve state (disabled)
            // - If no reserve character is set, hide all reserve buttons
            if (isReadOnlyUI) {
                if (hasReserveCharacter && isReserveCharacter) {
                    return `<button class="reserve-btn active" disabled title="Reserve character">Reserve</button>`;
                }
                return '';
            }
            
            // If this card is the selected reserve character, show the "Reserve" button
            if (isReserveCharacter) {
                const buttonText = 'Reserve';
                const buttonClass = 'reserve-btn active';
                const onclickFunction = `deselectReserveCharacter(${index})`;
                return `<button class="${buttonClass}" onclick="${onclickFunction}">${buttonText}</button>`;
            }
            // If a reserve character is selected but doesn't match any card, show "Select Reserve" on all cards
            // This allows users to fix invalid reserve character references
            // Otherwise, if reserve matches another card, hide the button
            else {
                // Check if the reserve character matches any card in the deck
                let reserveMatchesAnyCard = false;
                if (hasReserveCharacter && window.deckEditorCards) {
                    const normalizedReserveId = extractUUID(reserveCharacterId);
                    for (const card of window.deckEditorCards) {
                        if (card.type === 'character') {
                            const normalizedCardId = extractUUID(card.cardId);
                            if (normalizedReserveId === normalizedCardId) {
                                reserveMatchesAnyCard = true;
                                break;
                            }
                            if (card.selectedAlternateCardId) {
                                const normalizedAltId = extractUUID(card.selectedAlternateCardId);
                                if (normalizedReserveId === normalizedAltId) {
                                    reserveMatchesAnyCard = true;
                                    break;
                                }
                            }
                            if (card.selectedAlternateCardIds && Array.isArray(card.selectedAlternateCardIds)) {
                                for (const altId of card.selectedAlternateCardIds) {
                                    const normalizedAltId = extractUUID(altId);
                                    if (normalizedReserveId === normalizedAltId) {
                                        reserveMatchesAnyCard = true;
                                        break;
                                    }
                                }
                                if (reserveMatchesAnyCard) break;
                            }
                        }
                    }
                }
                
                // If reserve doesn't match any card, show "Select Reserve" button (allows fixing invalid reference)
                // If reserve matches another card, hide the button
                if (hasReserveCharacter && !reserveMatchesAnyCard) {
                    const buttonText = 'Select Reserve';
                    const buttonClass = 'reserve-btn';
                    const onclickFunction = `selectReserveCharacter('${cardId}', ${index})`;
                    return `<button class="${buttonClass}" onclick="${onclickFunction}">${buttonText}</button>`;
                } else if (hasReserveCharacter && reserveMatchesAnyCard) {
                    return ''; // Reserve matches another card, hide button
                } else {
                    // No reserve character selected, show "Select Reserve" button
                    const buttonText = 'Select Reserve';
                    const buttonClass = 'reserve-btn';
                    const onclickFunction = `selectReserveCharacter('${cardId}', ${index})`;
                    return `<button class="${buttonClass}" onclick="${onclickFunction}">${buttonText}</button>`;
                }
            }
        }

        function updateReserveButtons() {
            
            // Find all character cards in the deck editor (both Tile View and Card View)
            const characterCards = document.querySelectorAll('.deck-card-editor-item, .deck-card-card-view-item');
            
            characterCards.forEach((cardElement, index) => {
                // Check if this is a character card
                const cardInfo = cardElement.querySelector('.deck-card-editor-name');
                let matchingCard = null;
                
                if (cardInfo) {
                    // Tile View: Find by card name
                    const cardName = cardInfo.textContent.trim();
                    matchingCard = window.deckEditorCards.find(card => {
                        if (card.type !== 'character') return false;
                        const character = window.availableCardsMap.get(card.cardId);
                        return character && character.name === cardName;
                    });
                } else if (cardElement.hasAttribute('data-index')) {
                    // Card View: Find by data-index attribute
                    const cardIndex = parseInt(cardElement.getAttribute('data-index'));
                    if (cardIndex >= 0 && cardIndex < window.deckEditorCards.length) {
                        const card = window.deckEditorCards[cardIndex];
                        if (card && card.type === 'character') {
                            matchingCard = card;
                        }
                    }
                }
                
                if (!matchingCard) return;
                
                if (matchingCard) {
                    const cardId = matchingCard.cardId;
                    const cardIndex = window.deckEditorCards.indexOf(matchingCard);
                    
                    // Handle both Tile View and Card View
                    let reserveContainer = cardElement.querySelector('.deck-card-editor-reserve');
                    if (!reserveContainer) {
                        // Card View: look for reserve button in card-view-actions
                        reserveContainer = cardElement.querySelector('.card-view-actions');
                    }
                    
                    if (reserveContainer) {
                        // Get the new button HTML
                        const newButtonHTML = getReserveCharacterButton(cardId, cardIndex);
                        
                        // For Card View, we need to preserve other buttons and only update the reserve button
                        if (cardElement.classList.contains('deck-card-card-view-item')) {
                            // Card View: find and update only the reserve button
                            const existingReserveBtn = reserveContainer.querySelector('.reserve-btn');
                            if (existingReserveBtn) {
                                existingReserveBtn.outerHTML = newButtonHTML;
                            } else if (newButtonHTML) {
                                // Add reserve button if it doesn't exist
                                reserveContainer.innerHTML += newButtonHTML;
                            }
                        } else {
                            // Tile View: replace entire container content
                            if (reserveContainer.innerHTML !== newButtonHTML) {
                                reserveContainer.innerHTML = newButtonHTML;
                            }
                        }
                    }
                }
            });

            // Also update reserve buttons in list view - only in Characters section
            const charactersListItems = document.querySelectorAll('#deck-list-items-character .deck-list-item');
            charactersListItems.forEach((listItem, index) => {
                // Find the card name from the list item
                const cardNameElement = listItem.querySelector('.deck-list-item-name');
                if (!cardNameElement) return;
                
                const cardName = cardNameElement.textContent.trim();
                
                // Find the corresponding character card in window.deckEditorCards by name
                const matchingCard = window.deckEditorCards.find(card => {
                    if (card.type !== 'character') return false;
                    const character = window.availableCardsMap.get(card.cardId);
                    return character && character.name === cardName;
                });
                
                if (matchingCard) {
                    const cardId = matchingCard.cardId;
                    const originalIndex = window.deckEditorCards.indexOf(matchingCard);
                    const actionsContainer = listItem.querySelector('.deck-list-item-actions');
                    
                    if (actionsContainer) {
                        // Find existing reserve button and remove it
                        const existingReserveBtn = actionsContainer.querySelector('.reserve-btn');
                        if (existingReserveBtn) {
                            existingReserveBtn.remove();
                        }
                        
                        // Get the new button HTML
                        const newButtonHTML = getReserveCharacterButton(cardId, originalIndex);
                        
                        // Insert the new button before the remove button
                        const removeBtn = actionsContainer.querySelector('.deck-list-item-remove');
                        if (removeBtn && newButtonHTML) {
                            removeBtn.insertAdjacentHTML('beforebegin', newButtonHTML);
                        }
                    }
                }
            });
        }


        async function selectReserveCharacter(cardId, index) {
            
            if (!currentDeckId && currentDeckId !== null) {
                showNotification('No deck selected', 'error');
                return;
            }

            if (!currentDeckData) {
                showNotification('No deck data available', 'error');
                return;
            }

            // Read-only mode removed - now handled by backend flag


            // Update local deck data only - changes will be persisted when user clicks Save
            if (!currentDeckData.metadata) {
                currentDeckData.metadata = {};
            }
            
            currentDeckData.metadata.reserve_character = cardId;
            
            showNotification('Reserve character selected! (Click Save to persist changes)', 'success');
            
            // Update reserve buttons without re-rendering the entire deck to preserve layout
            updateReserveButtons();
            
            // Update deck summary to reflect new threat calculation
            // Use window.deckEditorCards which is the working copy of deck cards
            await updateDeckSummary(window.deckEditorCards);
            
        }

        async function deselectReserveCharacter(index) {
            
            if (!currentDeckId && currentDeckId !== null) {
                showNotification('No deck selected', 'error');
                return;
            }

            if (!currentDeckData) {
                showNotification('No deck data available', 'error');
                return;
            }

            // Read-only mode removed - now handled by backend flag


            // Update local deck data only - changes will be persisted when user clicks Save
            if (!currentDeckData.metadata) {
                currentDeckData.metadata = {};
            }
            
            currentDeckData.metadata.reserve_character = null;
            
            showNotification('Reserve character deselected! (Click Save to persist changes)', 'success');
            
            // Update reserve buttons without re-rendering the entire deck to preserve layout
            updateReserveButtons();
            
            // Update deck summary to reflect new threat calculation
            // Use window.deckEditorCards which is the working copy of deck cards
            await updateDeckSummary(window.deckEditorCards);
            
        }

        // Mission Display Tile Selection Functions
        function getDisplayMissionButton(cardId, index) {
            // Hide in read-only mode
            if (document.body.classList.contains('read-only-mode')) {
                return '';
            }

            // Only applies to mission cards
            if (!window.deckEditorCards || !window.deckEditorCards[index] || window.deckEditorCards[index].type !== 'mission') {
                return '';
            }

            const deckData = window.currentDeckData || currentDeckData;
            const selectedMissionId = deckData?.metadata?.display_mission_card_id || null;
            const hasSelection = !!selectedMissionId;

            // Check if selection matches any mission card in deck
            let selectionMatchesAnyMission = false;
            if (hasSelection && window.deckEditorCards) {
                selectionMatchesAnyMission = window.deckEditorCards.some(c => c?.type === 'mission' && c.cardId === selectedMissionId);
            }

            const isSelected = hasSelection && selectedMissionId === cardId;

            // If selected and this is the selected mission -> show active Display button
            if (isSelected) {
                return `<button class="reserve-btn display-mission-btn active" onclick="deselectDisplayMission(${index})">Display</button>`;
            }

            // If there is a valid selection on another mission -> hide button here
            if (hasSelection && selectionMatchesAnyMission) {
                return '';
            }

            // No selection (or stale selection) -> show Display button on all missions
            return `<button class="reserve-btn display-mission-btn" onclick="selectDisplayMission('${cardId}', ${index})">Display</button>`;
        }

        function updateDisplayMissionButtons() {
            // Update buttons in Tile View (deck-card-editor-item) and Card View (deck-card-card-view-item)
            const allCards = document.querySelectorAll('.deck-card-editor-item, .deck-card-card-view-item');
            allCards.forEach((cardElement) => {
                const cardIndexAttr = cardElement.getAttribute('data-index');
                if (cardIndexAttr === null || cardIndexAttr === undefined) return;
                const cardIndex = parseInt(cardIndexAttr);
                if (Number.isNaN(cardIndex)) return;

                const card = window.deckEditorCards && window.deckEditorCards[cardIndex];
                if (!card || card.type !== 'mission') return;

                let actionsContainer = cardElement.querySelector('.deck-card-editor-actions');
                if (!actionsContainer) {
                    // Card View: actions container uses card-view-actions
                    actionsContainer = cardElement.querySelector('.card-view-actions');
                }
                if (!actionsContainer) return;

                // Remove any existing Display buttons (identified by text and reserve-btn class)
                actionsContainer.querySelectorAll('button.reserve-btn').forEach(btn => {
                    if ((btn.textContent || '').trim() === 'Display') {
                        btn.remove();
                    }
                });

                const newButtonHTML = getDisplayMissionButton(card.cardId, cardIndex);
                if (!newButtonHTML) return;

                // Insert near the other small action buttons
                actionsContainer.insertAdjacentHTML('beforeend', newButtonHTML);
            });

            // Update buttons in list view - Missions section only
            const missionsListItems = document.querySelectorAll('#deck-list-items-mission .deck-list-item');
            missionsListItems.forEach((listItem) => {
                const nameEl = listItem.querySelector('.deck-list-item-name');
                if (!nameEl) return;
                const cardName = nameEl.textContent.trim();

                const matchingCard = window.deckEditorCards?.find(c => {
                    if (c.type !== 'mission') return false;
                    const mission = window.availableCardsMap?.get(c.cardId);
                    const missionName = mission?.name || mission?.card_name || '';
                    return missionName === cardName;
                });
                if (!matchingCard) return;

                const originalIndex = window.deckEditorCards.indexOf(matchingCard);
                const actionsContainer = listItem.querySelector('.deck-list-item-actions');
                if (!actionsContainer) return;

                // Remove existing Display button
                actionsContainer.querySelectorAll('button.reserve-btn').forEach(btn => {
                    if ((btn.textContent || '').trim() === 'Display') {
                        btn.remove();
                    }
                });

                const newButtonHTML = getDisplayMissionButton(matchingCard.cardId, originalIndex);
                if (!newButtonHTML) return;

                const removeBtn = actionsContainer.querySelector('.deck-list-item-remove');
                if (removeBtn) {
                    removeBtn.insertAdjacentHTML('beforebegin', newButtonHTML);
                } else {
                    actionsContainer.insertAdjacentHTML('beforeend', newButtonHTML);
                }
            });
        }

        async function selectDisplayMission(cardId, index) {
            if (!currentDeckData) {
                showNotification('No deck data available', 'error');
                return;
            }
            if (!currentDeckData.metadata) {
                currentDeckData.metadata = {};
            }

            // Only allow selecting mission cards
            const card = window.deckEditorCards && window.deckEditorCards[index];
            if (!card || card.type !== 'mission') {
                return;
            }

            currentDeckData.metadata.display_mission_card_id = cardId;
            showNotification('Mission selected for deck tile! (Click Save to persist changes)', 'success');
            updateDisplayMissionButtons();
        }

        async function deselectDisplayMission(index) {
            if (!currentDeckData) {
                showNotification('No deck data available', 'error');
                return;
            }
            if (!currentDeckData.metadata) {
                currentDeckData.metadata = {};
            }

            currentDeckData.metadata.display_mission_card_id = null;
            showNotification('Mission display selection cleared! (Click Save to persist changes)', 'success');
            updateDisplayMissionButtons();
        }

        // saveDeckChanges function moved to external file

        // Global alias for updateDeckEditorCardCount
        window.updateDeckCardCount = function() {
            updateDeckEditorCardCount();
            // Also update deck summary to ensure button states are correct
            if (typeof updateDeckSummary === 'function') {
                updateDeckSummary(window.deckEditorCards);
            } else {
            }
        };


    </script>
</body>
</html>