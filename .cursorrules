# Cursor AI Assistant Rules for Overpower Deckbuilder

## Testing Requirements
- **ALWAYS run all unit tests before committing to git**
- **NEVER commit to git if any unit tests fail**
- Use `npm run test:unit` to run all unit tests
- If tests fail, fix the issues before committing
- If tests pass, proceed with git commit

## Integration Test Failure Analysis
- **When integration tests fail, ALWAYS verify the failure is due to intended changes**
- **NEVER assume test failures are acceptable without analysis**
- If an integration test fails after making changes:
  1. **First, identify what specific change caused the failure**
  2. **Determine if the failure is expected due to intentional modifications**
  3. **If the failure is unexpected, investigate and fix the root cause**
  4. **If the failure is expected, update the test to match the new intended behavior**
  5. **Document why the test needed to change in commit messages**
- **Always run integration tests after significant changes to ensure no unintended regressions**
- **When fixing integration tests, ensure the fix aligns with the intended functionality changes**

## Database Cleanup Requirements
- **ALL tests that create users or decks in the database MUST clean up what they create**
- **Cleanup must happen regardless of test success or failure**
- Use `integrationTestUtils.trackTestDeck(deckId)` for all deck creation
- Use `integrationTestUtils.createTestUser()` for user creation (auto-cleanup)
- Use `createTrackedDeck()` helper function for API-created decks
- **NEVER leave orphaned test data in the database**
- Always verify cleanup is working by checking database after test runs
- Use try/finally blocks or helper functions to ensure cleanup happens

## Code Quality Standards
- Follow existing code patterns and conventions
- Maintain consistent styling and formatting
- Add appropriate error handling
- Include helpful debug logging when needed
- Write comprehensive unit tests for new functionality

## Debug Statement Management
- **ALWAYS remove debug statements after figuring out an issue**
- **NEVER commit debug statements to git**
- Remove console.log, console.debug, and other temporary debugging code before committing
- Keep only essential error logging (console.error) and important success messages
- Clean up any temporary debugging variables or test code
- Ensure console output is clean and professional for production use

## Git Workflow
1. Make code changes
2. Run `npm run test:unit` to verify all tests pass
3. If tests fail, fix issues and re-run tests
4. Only commit when all tests are passing
5. Use descriptive commit messages

## Project-Specific Guidelines
- This is a TypeScript/Node.js project with Jest testing
- Frontend uses vanilla JavaScript (no frameworks)
- Backend uses Express.js with PostgreSQL
- All changes should maintain backward compatibility
- Follow the existing component structure (globalNav, etc.)

## UI/UX Guidelines
- **All global navigation popups and tooltips must appear above main page content**
- Use z-index: 9999 for global navigation dropdowns, popups, and tooltips
- Ensure proper stacking context for navigation elements
- Test that popups are visible and not hidden behind other page elements

## Style Guide Maintenance
- **ALWAYS update the style guide (STYLE_GUIDE.md) when making visual changes to the application**
- **NEVER make UI/UX changes without documenting them in the style guide**
- When updating visual elements, include:
  1. **CSS class names and selectors used**
  2. **Exact color values, spacing, and positioning**
  3. **Layout specifications and flex/grid properties**
  4. **Button styling and interactive states**
  5. **Responsive behavior and breakpoints**
- **Update the Table of Contents** when adding new sections
- **Include code examples** for complex styling patterns
- **Document the reasoning** behind visual design decisions
- **Maintain consistency** with existing style guide format and structure

## Server Health Check Requirements
- **ALWAYS use the health check endpoint when verifying server status**
- **NEVER use basic curl or simple port checks for server verification**
- Use `curl -s http://localhost:3000/health | jq .` for health checks
- **ALWAYS format health check output in a friendly, readable format**
- Include key metrics like status, uptime, database connectivity, and response time
- **ALWAYS include latest git commit and migration information in health check summaries**
- Present health check results with clear status indicators (âœ…/âŒ)
- Use this command for friendly formatted output:
  ```bash
  curl -s http://localhost:3000/health | jq -r '
  "ğŸ¥ Server Health Check
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚ Status: " + (if .status == "OK" then "âœ… OK" else "âŒ ERROR" end) + "                                               â”‚
  â”‚ Uptime: " + (.uptime | floor | . / 3600 | floor | tostring) + "h " + ((.uptime | floor) % 3600 / 60 | floor | tostring) + "m " + ((.uptime | floor) % 60 | tostring) + "s                                         â”‚
  â”‚ Database: " + (if .database.status == "OK" then "âœ… Connected" else "âŒ Error" end) + " (" + (.database.latency // "N/A") + ")                      â”‚
  â”‚ Response Time: " + .latency + "                                        â”‚
  â”‚ Environment: " + .environment + "                                   â”‚
  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
  â”‚ Latest Git Commit:                                          â”‚
  â”‚ " + .git.shortCommit + " - " + .git.commitMessage + " â”‚
  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
  â”‚ Latest Migration:                                           â”‚
  â”‚ V" + .database.migrations.latest.version + " - " + .database.migrations.latest.description + " â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜"'
  ```

## Testing Commands
- `npm run test:unit` - Run all unit tests
- `npm run test:integration` - Run integration tests  
- `npm run test:all` - Run both unit and integration tests
- `npm run build` - Build the project
- `npm run dev` - Start development server

## Integration Test Output Format
- **ALWAYS provide table-style output when running integration tests**
- Use the format with columns: Test Suite | Passed | Failed | Total | Status
- Include overall success rate percentage and summary statistics
- This helps the user quickly digest test findings and identify issues
- Example format:
  ```
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚ Test Suite                          â”‚ Passed  â”‚ Failed  â”‚ Total   â”‚ Status  â”‚
  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
  â”‚ testSuiteName                       â”‚      12 â”‚       0 â”‚      12 â”‚  âœ… PASS â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  ```

## Integration Test Categorization
- **ALWAYS try to match new integration tests to the best category first before using "Remaining" as fallback**
- **Use descriptive filename patterns that align with existing test categories:**
  - **Security & Auth**: `*-security-*.test.ts`, `*-auth-*.test.ts`, `guest-*.test.ts`, `authentication*.test.ts`
  - **Search & Filtering**: `*search*.test.ts`, `*filtering*.test.ts`, `stat-type-filtering*.test.ts`, `ally-search*.test.ts`
  - **Deck Core**: `deckBuilding.test.ts`, `deckManagement.test.ts`, `deck-navigation-flow.test.ts`, `deck-editor-search-new-deck.test.ts`, `deckClickability.test.ts`, `deckEditabilityBrowser.test.ts`, `deckEditabilityHTML.test.ts`, `deckTitleDescriptionEditability.test.ts`, `deck-validation-unusable-cards.test.ts`, `limitedDeckIntegration.test.ts`, `limitedDeckSaveAndLoad.test.ts`, `limitedDeckSimpleIntegration.test.ts`
  - **Deck Security**: `deck-editor-role-access.test.ts`, `deck-ownership-security-simple.test.ts`, `deck-ownership-security.test.ts`, `deck-save-frontend-validation.test.ts`, `deck-save-security-api.test.ts`, `deck-save-security-comprehensive.test.ts`, `deck-save-security-simple.test.ts`
  - **Game Logic**: `reserve-character*.test.ts`, `character*.test.ts`, `power*.test.ts`, `teamwork*.test.ts`, `event-mission-filtering*.test.ts`
  - **UI/UX & Frontend**: `*HTML*.test.ts`, `*Browser*.test.ts`, `*Clickability*.test.ts`, `*Editability*.test.ts`, `*Layout*.test.ts`, `*Navigation*.test.ts`, `*Tooltip*.test.ts`
  - **Remaining**: Only use for tests that don't fit the above categories (e.g., `create*.test.ts`, `user*.test.ts`, `cross*.test.ts`, `new*.test.ts`, `auto*.test.ts`, `database*.test.ts`, `change*.test.ts`, `username*.test.ts`, `alternate*.test.ts`)
- **Consider test execution time when categorizing** - aim for balanced groups (5-15 minutes each)
- **Update the GitHub Actions workflow patterns** if adding new test categories or if existing patterns become imbalanced
- **Document new categorization patterns** in commit messages when adding them

## Remember
- Quality over speed
- Test-driven development approach
- Always verify functionality before committing
- Ask for clarification if requirements are unclear
